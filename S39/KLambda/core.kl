(defun shen.shen->kl (V502) (let W503 (shen.shen->kl-h V502) (shen.record-and-evaluate W503)))

(defun shen.record-and-evaluate (V504) (cond ((and (cons? V504) (and (= defun (hd V504)) (and (cons? (tl V504)) (and (cons? (tl (tl V504))) (and (cons? (tl (tl (tl V504)))) (= () (tl (tl (tl (tl V504)))))))))) (let W505 (if (shen.sysfunc? (hd (tl V504))) (simple-error (shen.app (hd (tl V504)) " is not a legitimate function name
" shen.a)) shen.skip) (let W506 (shen.store-arity (hd (tl V504)) (length (hd (tl (tl V504))))) (let W507 (shen.record-kl (hd (tl V504)) V504) (let W508 (eval-kl V504) (shen.fn-print (hd (tl V504)))))))) (true V504)))

(defun shen.shen->kl-h (V509) (cond ((and (cons? V509) (and (= define (hd V509)) (cons? (tl V509)))) (shen.shendef->kldef (hd (tl V509)) (tl (tl V509)))) ((and (cons? V509) (and (= defun (hd V509)) (and (cons? (tl V509)) (and (cons? (tl (tl V509))) (and (cons? (tl (tl (tl V509)))) (= () (tl (tl (tl (tl V509)))))))))) V509) ((and (cons? V509) (and (= type (hd V509)) (and (cons? (tl V509)) (and (cons? (tl (tl V509))) (= () (tl (tl (tl V509)))))))) (cons type (cons (hd (tl V509)) (cons (shen.rcons_form (hd (tl (tl V509)))) ())))) ((and (cons? V509) (and (= input+ (hd V509)) (and (cons? (tl V509)) (and (cons? (tl (tl V509))) (= () (tl (tl (tl V509)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V509))) (tl (tl V509))))) ((cons? V509) (map (lambda Z510 (shen.shen->kl-h Z510)) V509)) (true V509)))

(defun shen.shendef->kldef (V511 V512) (compile (lambda Z513 (shen.<define> Z513)) (cons V511 V512)))

(defun shen.<define> (V514) (let W515 (let W516 (shen.<name> V514) (if (shen.parse-failure? W516) (shen.parse-failure) (let W517 (shen.<-out W516) (let W518 (shen.in-> W516) (if (shen.hds=? W518 {) (let W519 (tail W518) (let W520 (shen.<signature> W519) (if (shen.parse-failure? W520) (shen.parse-failure) (let W521 (shen.in-> W520) (if (shen.hds=? W521 }) (let W522 (tail W521) (let W523 (shen.<rules> W522) (if (shen.parse-failure? W523) (shen.parse-failure) (let W524 (shen.<-out W523) (let W525 (shen.in-> W523) (shen.comb W525 (shen.shendef->kldef-h W517 W524))))))) (shen.parse-failure)))))) (shen.parse-failure)))))) (if (shen.parse-failure? W515) (let W526 (let W527 (shen.<name> V514) (if (shen.parse-failure? W527) (shen.parse-failure) (let W528 (shen.<-out W527) (let W529 (shen.in-> W527) (let W530 (shen.<rules> W529) (if (shen.parse-failure? W530) (shen.parse-failure) (let W531 (shen.<-out W530) (let W532 (shen.in-> W530) (shen.comb W532 (shen.shendef->kldef-h W528 W531)))))))))) (if (shen.parse-failure? W526) (shen.parse-failure) W526)) W515)))

(defun shen.shendef->kldef-h (V533 V534) (let W535 (map (lambda Z536 (fst Z536)) V534) (let W537 (shen.arity-chk V533 W535) (let W538 (map (lambda Z539 (shen.free-var-chk V533 Z539)) V534) (let W540 (shen.unprotect V534) (let W541 (shen.factorise-code (shen.compile-to-kl V533 W540 W537)) W541))))))

(defun shen.unprotect (V542) (cond ((tuple? V542) (@p (shen.unprotect (fst V542)) (shen.unprotect (snd V542)))) ((and (cons? V542) (and (= protect (hd V542)) (and (cons? (tl V542)) (= () (tl (tl V542)))))) (shen.unprotect (hd (tl V542)))) ((cons? V542) (map (lambda Z543 (shen.unprotect Z543)) V542)) (true V542)))

(defun shen.<name> (V544) (let W545 (if (cons? V544) (let W546 (head V544) (let W547 (tail V544) (shen.comb W547 (if (and (symbol? W546) (not (variable? W546))) W546 (simple-error (shen.app W546 " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? W545) (shen.parse-failure) W545)))

(defun shen.<signature> (V548) (let W549 (if (cons? V548) (let W550 (head V548) (let W551 (tail V548) (let W552 (shen.<signature> W551) (if (shen.parse-failure? W552) (shen.parse-failure) (let W553 (shen.<-out W552) (let W554 (shen.in-> W552) (if (not (element? W550 (cons { (cons } ())))) (shen.comb W554 (cons W550 W553)) (shen.parse-failure)))))))) (shen.parse-failure)) (if (shen.parse-failure? W549) (let W555 (let W556 (<e> V548) (if (shen.parse-failure? W556) (shen.parse-failure) (let W557 (shen.in-> W556) (shen.comb W557 ())))) (if (shen.parse-failure? W555) (shen.parse-failure) W555)) W549)))

(defun shen.<rules> (V558) (let W559 (let W560 (shen.<rule> V558) (if (shen.parse-failure? W560) (shen.parse-failure) (let W561 (shen.<-out W560) (let W562 (shen.in-> W560) (let W563 (shen.<rules> W562) (if (shen.parse-failure? W563) (shen.parse-failure) (let W564 (shen.<-out W563) (let W565 (shen.in-> W563) (shen.comb W565 (cons (shen.linearise W561) W564)))))))))) (if (shen.parse-failure? W559) (let W566 (let W567 (<!> V558) (if (shen.parse-failure? W567) (shen.parse-failure) (let W568 (shen.<-out W567) (let W569 (shen.in-> W567) (shen.comb W569 (if (empty? W568) () (simple-error (cn "Shen syntax error here:
 " (shen.app W568 "
 ..." shen.r))))))))) (if (shen.parse-failure? W566) (shen.parse-failure) W566)) W559)))

(defun shen.linearise (V572) (cond ((tuple? V572) (shen.linearise-h (fst V572) (fst V572) () (snd V572))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V585 V586 V587 V588) (cond ((= () V585) (@p V586 V588)) ((and (cons? V585) (cons? (hd V585))) (shen.linearise-h (append (hd V585) (tl V585)) V586 V587 V588)) ((and (cons? V585) (variable? (hd V585))) (if (element? (hd V585) V587) (let W589 (gensym V) (shen.linearise-h (tl V585) (shen.rep-X (hd V585) W589 V586) V587 (cons where (cons (cons = (cons W589 (cons (hd V585) ()))) (cons V588 ()))))) (shen.linearise-h (tl V585) V586 (cons (hd V585) V587) V588))) ((cons? V585) (shen.linearise-h (tl V585) V586 V587 V588)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V590) (let W591 (let W592 (shen.<patterns> V590) (if (shen.parse-failure? W592) (shen.parse-failure) (let W593 (shen.<-out W592) (let W594 (shen.in-> W592) (if (shen.hds=? W594 ->) (let W595 (tail W594) (if (cons? W595) (let W596 (head W595) (let W597 (tail W595) (if (shen.hds=? W597 where) (let W598 (tail W597) (if (cons? W598) (let W599 (head W598) (let W600 (tail W598) (shen.comb W600 (@p W593 (cons where (cons W599 (cons W596 ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W591) (let W601 (let W602 (shen.<patterns> V590) (if (shen.parse-failure? W602) (shen.parse-failure) (let W603 (shen.<-out W602) (let W604 (shen.in-> W602) (if (shen.hds=? W604 ->) (let W605 (tail W604) (if (cons? W605) (let W606 (head W605) (let W607 (tail W605) (shen.comb W607 (@p W603 W606)))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W601) (let W608 (let W609 (shen.<patterns> V590) (if (shen.parse-failure? W609) (shen.parse-failure) (let W610 (shen.<-out W609) (let W611 (shen.in-> W609) (if (shen.hds=? W611 <-) (let W612 (tail W611) (if (cons? W612) (let W613 (head W612) (let W614 (tail W612) (if (shen.hds=? W614 where) (let W615 (tail W614) (if (cons? W615) (let W616 (head W615) (let W617 (tail W615) (shen.comb W617 (@p W610 (cons where (cons W616 (cons (cons shen.choicepoint! (cons W613 ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W608) (let W618 (let W619 (shen.<patterns> V590) (if (shen.parse-failure? W619) (shen.parse-failure) (let W620 (shen.<-out W619) (let W621 (shen.in-> W619) (if (shen.hds=? W621 <-) (let W622 (tail W621) (if (cons? W622) (let W623 (head W622) (let W624 (tail W622) (shen.comb W624 (@p W620 (cons shen.choicepoint! (cons W623 ())))))) (shen.parse-failure))) (shen.parse-failure)))))) (if (shen.parse-failure? W618) (shen.parse-failure) W618)) W608)) W601)) W591)))

(defun shen.<patterns> (V625) (let W626 (let W627 (shen.<pattern> V625) (if (shen.parse-failure? W627) (shen.parse-failure) (let W628 (shen.<-out W627) (let W629 (shen.in-> W627) (let W630 (shen.<patterns> W629) (if (shen.parse-failure? W630) (shen.parse-failure) (let W631 (shen.<-out W630) (let W632 (shen.in-> W630) (shen.comb W632 (cons W628 W631)))))))))) (if (shen.parse-failure? W626) (let W633 (let W634 (<e> V625) (if (shen.parse-failure? W634) (shen.parse-failure) (let W635 (shen.in-> W634) (shen.comb W635 ())))) (if (shen.parse-failure? W633) (shen.parse-failure) W633)) W626)))

(defun shen.<pattern> (V636) (let W637 (if (shen.ccons? V636) (let W638 (head V636) (let W639 (tail V636) (let W640 (shen.<constructor> W638) (if (shen.parse-failure? W640) (shen.parse-failure) (let W641 (shen.<-out W640) (let W642 (shen.in-> W640) (let W643 (shen.<pattern1> W642) (if (shen.parse-failure? W643) (shen.parse-failure) (let W644 (shen.<-out W643) (let W645 (shen.in-> W643) (let W646 (shen.<pattern2> W645) (if (shen.parse-failure? W646) (shen.parse-failure) (let W647 (shen.<-out W646) (let W648 (shen.in-> W646) (let W649 (<end> W648) (if (shen.parse-failure? W649) (shen.parse-failure) (let W650 (shen.in-> W649) (shen.comb W639 (cons W641 (cons W644 (cons W647 ()))))))))))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? W637) (let W651 (if (shen.ccons? V636) (let W652 (head V636) (let W653 (tail V636) (if (shen.hds=? W652 vector) (let W654 (tail W652) (if (shen.hds=? W654 0) (let W655 (tail W654) (let W656 (<end> W655) (if (shen.parse-failure? W656) (shen.parse-failure) (let W657 (shen.in-> W656) (shen.comb W653 (cons vector (cons 0 ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W651) (let W658 (if (cons? V636) (let W659 (head V636) (let W660 (tail V636) (if (cons? W659) (shen.comb W660 (shen.constructor-error W659)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W658) (let W661 (let W662 (shen.<simple-pattern> V636) (if (shen.parse-failure? W662) (shen.parse-failure) (let W663 (shen.<-out W662) (let W664 (shen.in-> W662) (shen.comb W664 W663))))) (if (shen.parse-failure? W661) (shen.parse-failure) W661)) W658)) W651)) W637)))

(defun shen.<constructor> (V665) (let W666 (if (cons? V665) (let W667 (head V665) (let W668 (tail V665) (if (shen.constructor? W667) (shen.comb W668 W667) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W666) (shen.parse-failure) W666)))

(defun shen.constructor? (V669) (element? V669 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V670) (simple-error (shen.app V670 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V671) (let W672 (if (cons? V671) (let W673 (head V671) (let W674 (tail V671) (if (= W673 _) (shen.comb W674 (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W672) (let W675 (if (cons? V671) (let W676 (head V671) (let W677 (tail V671) (if (not (element? W676 (cons -> (cons <- ())))) (shen.comb W677 W676) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W675) (shen.parse-failure) W675)) W672)))

(defun shen.<pattern1> (V678) (let W679 (let W680 (shen.<pattern> V678) (if (shen.parse-failure? W680) (shen.parse-failure) (let W681 (shen.<-out W680) (let W682 (shen.in-> W680) (shen.comb W682 W681))))) (if (shen.parse-failure? W679) (shen.parse-failure) W679)))

(defun shen.<pattern2> (V683) (let W684 (let W685 (shen.<pattern> V683) (if (shen.parse-failure? W685) (shen.parse-failure) (let W686 (shen.<-out W685) (let W687 (shen.in-> W685) (shen.comb W687 W686))))) (if (shen.parse-failure? W684) (shen.parse-failure) W684)))

(defun shen.fn-print (V688) (let W689 (absvector 2) (let W690 (address-> W689 0 shen.printF) (let W691 (address-> W690 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V688) ")")))))) W691))))

(defun shen.printF (V692) (<-address V692 1))

(defun shen.arity-chk (V697 V698) (cond ((and (cons? V698) (= () (tl V698))) (length (hd V698))) ((and (cons? V698) (and (cons? (tl V698)) (= (length (hd V698)) (length (hd (tl V698)))))) (shen.arity-chk V697 (tl V698))) (true (simple-error (cn "arity error in " (shen.app V697 "
" shen.a))))))

(defun shen.free-var-chk (V699 V700) (cond ((tuple? V700) (shen.free-variable-error-message V699 (shen.find-free-vars (shen.extract-vars (fst V700)) (snd V700)))) (true (simple-error "partial function shen.free-var-chk"))))

(defun shen.free-variable-error-message (V701 V702) (if (empty? V702) shen.skip (do (pr (cn "free variables in " (shen.app V701 ":" shen.a)) (stoutput)) (do (map (lambda Z703 (pr (cn " " (shen.app Z703 "" shen.a)) (stoutput))) V702) (do (nl 1) (abort))))))

(defun shen.extract-vars (V706) (cond ((variable? V706) (cons V706 ())) ((cons? V706) (union (shen.extract-vars (hd V706)) (shen.extract-vars (tl V706)))) (true ())))

(defun shen.find-free-vars (V711 V712) (cond ((and (cons? V712) (and (= protect (hd V712)) (and (cons? (tl V712)) (= () (tl (tl V712)))))) ()) ((and (cons? V712) (and (= let (hd V712)) (and (cons? (tl V712)) (and (cons? (tl (tl V712))) (and (cons? (tl (tl (tl V712)))) (= () (tl (tl (tl (tl V712)))))))))) (union (shen.find-free-vars V711 (hd (tl (tl V712)))) (shen.find-free-vars (cons (hd (tl V712)) V711) (hd (tl (tl (tl V712))))))) ((and (cons? V712) (and (= lambda (hd V712)) (and (cons? (tl V712)) (and (cons? (tl (tl V712))) (= () (tl (tl (tl V712)))))))) (shen.find-free-vars (cons (hd (tl V712)) V711) (hd (tl (tl V712))))) ((cons? V712) (union (shen.find-free-vars V711 (hd V712)) (shen.find-free-vars V711 (tl V712)))) ((shen.free-variable? V712 V711) (cons V712 ())) (true ())))

(defun shen.free-variable? (V713 V714) (and (variable? V713) (not (element? V713 V714))))

(defun shen.record-kl (V715 V716) (do (set shen.*userdefs* (adjoin V715 (value shen.*userdefs*))) (put V715 shen.source V716 (value *property-vector*))))

(defun shen.compile-to-kl (V717 V718 V719) (let W720 (shen.parameters V719) (let W721 (shen.scan-body V717 (shen.kl-body V718 W720)) (let W722 (cons defun (cons V717 (cons W720 (cons (shen.cond-form W721) ())))) W722))))

(defun shen.parameters (V723) (cond ((= 0 V723) ()) (true (cons (gensym V) (shen.parameters (- V723 1))))))

(defun shen.cond-form (V726) (cond ((and (cons? V726) (and (cons? (hd V726)) (and (= true (hd (hd V726))) (and (cons? (tl (hd V726))) (= () (tl (tl (hd V726)))))))) (hd (tl (hd V726)))) (true (cons cond V726))))

(defun shen.scan-body (V735 V736) (cond ((= () V736) (cons (cons true (cons (cons shen.f-error (cons V735 ())) ())) ())) ((and (cons? V736) (shen.choicepoint? (hd V736))) (shen.choicepoint V735 (gensym Freeze) (gensym Result) (hd V736) (tl V736))) ((and (cons? V736) (and (cons? (hd V736)) (and (= true (hd (hd V736))) (and (cons? (tl (hd V736))) (= () (tl (tl (hd V736)))))))) (cons (hd V736) ())) ((cons? V736) (cons (hd V736) (shen.scan-body V735 (tl V736)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V743) (cond ((and (cons? V743) (and (cons? (tl V743)) (and (cons? (hd (tl V743))) (and (= shen.choicepoint! (hd (hd (tl V743)))) (and (cons? (tl (hd (tl V743)))) (and (= () (tl (tl (hd (tl V743))))) (= () (tl (tl V743))))))))) true) (true false)))

(defun shen.choicepoint (V759 V760 V761 V762 V763) (cond ((and (cons? V762) (and (cons? (tl V762)) (and (cons? (hd (tl V762))) (and (cons? (tl (hd (tl V762)))) (and (cons? (hd (tl (hd (tl V762))))) (and (= fail-if (hd (hd (tl (hd (tl V762)))))) (and (cons? (tl (hd (tl (hd (tl V762)))))) (and (cons? (tl (tl (hd (tl (hd (tl V762))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V762)))))))) (and (= () (tl (tl (hd (tl V762))))) (and (= () (tl (tl V762))) (= V759 (hd (tl (hd (tl (hd (tl V762)))))))))))))))))) (cons (cons true (cons (cons let (cons V760 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V762)))))) V763)) ())) (cons (cons if (cons (hd V762) (cons (cons let (cons V761 (cons (hd (tl (tl (hd (tl (hd (tl V762))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V762)))))) (cons V761 ())) (cons (cons thaw (cons V760 ())) (cons V761 ())))) ())))) (cons (cons thaw (cons V760 ())) ())))) ())))) ())) ())) ((and (cons? V762) (and (cons? (tl V762)) (and (cons? (hd (tl V762))) (and (cons? (tl (hd (tl V762)))) (and (= () (tl (tl (hd (tl V762))))) (= () (tl (tl V762)))))))) (cons (cons true (cons (cons let (cons V760 (cons (cons freeze (cons (cons cond (shen.scan-body V759 V763)) ())) (cons (cons if (cons (hd V762) (cons (cons let (cons V761 (cons (hd (tl (hd (tl V762)))) (cons (cons if (cons (cons = (cons V761 (cons (cons fail ()) ()))) (cons (cons thaw (cons V760 ())) (cons V761 ())))) ())))) (cons (cons thaw (cons V760 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V765 V766 V767) (cond ((= V765 V767) V766) ((cons? V767) (let W768 (shen.rep-X V765 V766 (hd V767)) (if (= W768 (hd V767)) (cons (hd V767) (shen.rep-X V765 V766 (tl V767))) (cons W768 (tl V767))))) (true V767)))

(defun shen.kl-body (V769 V770) (map (lambda Z771 (shen.triple-stack () (fst Z771) V770 (shen.alpha-convert (snd Z771)))) V769))

(defun shen.alpha-convert (V772) (cond ((and (cons? V772) (and (= lambda (hd V772)) (and (cons? (tl V772)) (and (cons? (tl (tl V772))) (= () (tl (tl (tl V772)))))))) (let W773 (gensym Z) (let W774 (cons lambda (cons W773 (cons (shen.beta (hd (tl V772)) W773 (hd (tl (tl V772)))) ()))) (map (lambda Z775 (shen.alpha-convert Z775)) W774)))) ((and (cons? V772) (and (= let (hd V772)) (and (cons? (tl V772)) (and (cons? (tl (tl V772))) (and (cons? (tl (tl (tl V772)))) (= () (tl (tl (tl (tl V772)))))))))) (let W776 (gensym W) (let W777 (cons let (cons W776 (cons (hd (tl (tl V772))) (cons (shen.beta (hd (tl V772)) W776 (hd (tl (tl (tl V772))))) ())))) (map (lambda Z778 (shen.alpha-convert Z778)) W777)))) ((cons? V772) (map (lambda Z779 (shen.alpha-convert Z779)) V772)) (true V772)))

(defun shen.triple-stack (V788 V789 V790 V791) (cond ((and (= () V789) (and (= () V790) (and (cons? V791) (and (= where (hd V791)) (and (cons? (tl V791)) (and (cons? (tl (tl V791))) (= () (tl (tl (tl V791)))))))))) (shen.triple-stack (cons (hd (tl V791)) V788) () () (hd (tl (tl V791))))) ((and (= () V789) (= () V790)) (cons (shen.rectify-test (reverse V788)) (cons V791 ()))) ((and (cons? V789) (and (cons? V790) (variable? (hd V789)))) (shen.triple-stack V788 (tl V789) (tl V790) (shen.beta (hd V789) (hd V790) V791))) ((and (cons? V789) (and (cons? (hd V789)) (and (cons? (tl (hd V789))) (and (cons? (tl (tl (hd V789)))) (and (= () (tl (tl (tl (hd V789))))) (cons? V790)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V789))) (cons (hd V790) ())) V788) (cons (hd (tl (hd V789))) (cons (hd (tl (tl (hd V789)))) (tl V789))) (cons (cons (shen.op1 (hd (hd V789))) (cons (hd V790) ())) (cons (cons (shen.op2 (hd (hd V789))) (cons (hd V790) ())) (tl V790))) (shen.beta (hd V789) (hd V790) V791))) ((and (cons? V789) (cons? V790)) (shen.triple-stack (cons (cons = (cons (hd V789) (cons (hd V790) ()))) V788) (tl V789) (tl V790) V791)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V794) (cond ((= () V794) true) ((and (cons? V794) (= () (tl V794))) (hd V794)) ((and (cons? V794) (cons? (tl V794))) (cons and (cons (hd V794) (cons (shen.rectify-test (tl V794)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V804 V805 V806) (cond ((= V804 V806) V805) ((and (cons? V806) (and (= lambda (hd V806)) (and (cons? (tl V806)) (and (cons? (tl (tl V806))) (and (= () (tl (tl (tl V806)))) (= V804 (hd (tl V806)))))))) V806) ((and (cons? V806) (and (= let (hd V806)) (and (cons? (tl V806)) (and (cons? (tl (tl V806))) (and (cons? (tl (tl (tl V806)))) (and (= () (tl (tl (tl (tl V806))))) (= V804 (hd (tl V806))))))))) (cons let (cons (hd (tl V806)) (cons (shen.beta (hd (tl V806)) V805 (hd (tl (tl V806)))) (tl (tl (tl V806))))))) ((cons? V806) (map (lambda Z807 (shen.beta V804 V805 Z807)) V806)) (true V806)))

(defun shen.op1 (V810) (cond ((= cons V810) hd) ((= @s V810) hdstr) ((= @p V810) fst) ((= @v V810) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V813) (cond ((= cons V813) tl) ((= @s V813) tlstr) ((= @p V813) snd) ((= @v V813) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V816) (cond ((= cons V816) cons?) ((= @s V816) shen.+string?) ((= @p V816) tuple?) ((= @v V816) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V817) (cond ((= "" V817) false) (true (string? V817))))

(defun shen.+vector? (V818) (cond ((= V818 (vector 0)) false) (true (vector? V818))))

(defun factorise (V821) (cond ((= + V821) (set shen.*factorise?* true)) ((= - V821) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V822) (cond ((value shen.*factorise?*) (shen.factor V822)) (true V822)))

(defun shen.factor (V823) (cond ((and (cons? V823) (and (= defun (hd V823)) (and (cons? (tl V823)) (and (cons? (tl (tl V823))) (and (cons? (tl (tl (tl V823)))) (and (cons? (hd (tl (tl (tl V823))))) (and (= cond (hd (hd (tl (tl (tl V823)))))) (= () (tl (tl (tl (tl V823)))))))))))) (cons defun (cons (hd (tl V823)) (cons (hd (tl (tl V823))) (cons (shen.factor-recognisors (tl (hd (tl (tl (tl V823)))))) ()))))) (true V823)))

(defun shen.factor-recognisors (V826) (cond ((and (cons? V826) (and (cons? (hd V826)) (and (= true (hd (hd V826))) (and (cons? (tl (hd V826))) (= () (tl (tl (hd V826)))))))) (hd (tl (hd V826)))) ((and (cons? V826) (and (cons? (hd V826)) (and (cons? (hd (hd V826))) (and (= and (hd (hd (hd V826)))) (and (cons? (tl (hd (hd V826)))) (and (cons? (tl (tl (hd (hd V826))))) (and (= () (tl (tl (tl (hd (hd V826)))))) (and (cons? (tl (hd V826))) (= () (tl (tl (hd V826)))))))))))) (let W827 (shen.pivot-on (hd (tl (hd (hd V826)))) V826 ()) (let W828 (fst W827) (if (shen.bad-pivot? W828) (cons if (cons (hd (hd V826)) (cons (hd (tl (hd V826))) (cons (shen.factor-recognisors (tl V826)) ())))) (let W829 (snd W827) (let W830 (shen.factor-recognisors W829) (let W831 (gensym GoTo) (let W832 (reverse (cons (cons true (cons (cons thaw (cons W831 ())) ())) W828)) (let W833 (cons let (cons W831 (cons (cons freeze (cons W830 ())) (cons (cons if (cons (hd (tl (hd (hd V826)))) (cons (shen.factor-selectors (hd (tl (hd (hd V826)))) (shen.factor-recognisors W832)) (cons (cons thaw (cons W831 ())) ())))) ())))) (shen.remove-indirection W833)))))))))) ((and (cons? V826) (and (cons? (hd V826)) (and (cons? (tl (hd V826))) (= () (tl (tl (hd V826))))))) (cons if (cons (hd (hd V826)) (cons (hd (tl (hd V826))) (cons (shen.factor-recognisors (tl V826)) ()))))) (true (simple-error "partial function shen.factor-recognisors"))))

(defun shen.bad-pivot? (V838) (cond ((and (cons? V838) (= () (tl V838))) true) (true false)))

(defun shen.remove-indirection (V839) (cond ((and (cons? V839) (and (= let (hd V839)) (and (cons? (tl V839)) (and (cons? (tl (tl V839))) (and (cons? (hd (tl (tl V839)))) (and (= freeze (hd (hd (tl (tl V839))))) (and (cons? (tl (hd (tl (tl V839))))) (and (cons? (hd (tl (hd (tl (tl V839)))))) (and (= thaw (hd (hd (tl (hd (tl (tl V839))))))) (and (cons? (tl (hd (tl (hd (tl (tl V839))))))) (and (= () (tl (tl (hd (tl (hd (tl (tl V839)))))))) (and (= () (tl (tl (hd (tl (tl V839)))))) (and (cons? (tl (tl (tl V839)))) (and (= () (tl (tl (tl (tl V839))))) (symbol? (hd (tl (hd (tl (hd (tl (tl V839)))))))))))))))))))))) (subst (hd (tl (hd (tl (hd (tl (tl V839))))))) (hd (tl V839)) (hd (tl (tl (tl V839)))))) (true V839)))

(defun shen.pivot-on (V842 V843 V844) (cond ((and (cons? V843) (and (cons? (hd V843)) (and (cons? (hd (hd V843))) (and (= and (hd (hd (hd V843)))) (and (cons? (tl (hd (hd V843)))) (and (cons? (tl (tl (hd (hd V843))))) (and (= () (tl (tl (tl (hd (hd V843)))))) (and (cons? (tl (hd V843))) (and (= () (tl (tl (hd V843)))) (= V842 (hd (tl (hd (hd V843)))))))))))))) (shen.pivot-on (hd (tl (hd (hd V843)))) (tl V843) (cons (cons (hd (tl (tl (hd (hd V843))))) (tl (hd V843))) V844))) ((and (cons? V843) (and (cons? (hd V843)) (and (cons? (tl (hd V843))) (and (= () (tl (tl (hd V843)))) (= V842 (hd (hd V843))))))) (shen.pivot-on (hd (hd V843)) (tl V843) (cons (cons true (tl (hd V843))) V844))) (true (@p V844 V843))))

(defun shen.factor-selectors (V847 V848) (cond ((and (cons? V847) (and (cons? (tl V847)) (= () (tl (tl V847))))) (let W849 (shen.op (hd V847)) (if (= shen.skip W849) V848 (shen.factor-selectors-h (cons (cons (shen.op1 W849) (tl V847)) (cons (cons (shen.op2 W849) (tl V847)) ())) V848)))) (true V848)))

(defun shen.op (V852) (cond ((= cons? V852) cons) ((= shen.+string? V852) @s) ((= shen.+vector? V852) @v) ((= tuple? V852) @p) (true shen.skip)))

(defun shen.factor-selectors-h (V853 V854) (cond ((= () V853) V854) ((cons? V853) (if (> (occurrences (hd V853) V854) 1) (let W855 (gensym Select) (cons let (cons W855 (cons (hd V853) (cons (shen.factor-selectors-h (tl V853) (subst W855 (hd V853) V854)) ()))))) (shen.factor-selectors-h (tl V853) V854))) (true (simple-error "partial function shen.factor-selectors-h"))))

