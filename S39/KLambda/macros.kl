(defun macroexpand (V5843) (let W5844 (map (lambda Z5845 (tl Z5845)) (value *macros*)) (shen.macroexpand-h V5843 W5844 W5844)))

(defun shen.macroexpand-h (V5854 V5855 V5856) (if (= () V5855) V5854 (if (cons? V5855) (let W5857 (shen.walk (hd V5855) V5854) (if (= V5854 W5857) (shen.macroexpand-h V5854 (tl V5855) V5856) (shen.macroexpand-h W5857 V5856 V5856))) (simple-error "implementation error in shen.macroexpand-h"))))

(defun shen.walk (V5858 V5859) (if (cons? V5859) (V5858 (map (lambda Z5860 (shen.walk V5858 Z5860)) V5859)) (V5858 V5859)))

(defun shen.macros (V5861) (let GoTo5862 (freeze V5861) (if (cons? V5861) (let Select5863 (hd V5861) (let Select5864 (tl V5861) (if (and (= defmacro Select5863) (cons? Select5864)) (shen.process-def (hd Select5864) (tl Select5864)) (if (= defcc Select5863) (shen.yacc->shen Select5864) (if (and (= u! Select5863) (and (cons? Select5864) (= () (tl Select5864)))) (cons protect (cons (shen.make-uppercase (hd Select5864)) ())) (if (and (= error Select5863) (cons? Select5864)) (cons simple-error (cons (shen.mkstr (hd Select5864) (tl Select5864)) ())) (if (and (= output Select5863) (cons? Select5864)) (cons pr (cons (shen.mkstr (hd Select5864) (tl Select5864)) (cons (cons stoutput ()) ()))) (if (and (= pr Select5863) (and (cons? Select5864) (= () (tl Select5864)))) (cons pr (cons (hd Select5864) (cons (cons stoutput ()) ()))) (if (and (= make-string Select5863) (cons? Select5864)) (shen.mkstr (hd Select5864) (tl Select5864)) (if (and (= lineread Select5863) (= () Select5864)) (cons lineread (cons (cons stinput ()) ())) (if (and (= input Select5863) (= () Select5864)) (cons input (cons (cons stinput ()) ())) (if (and (= read Select5863) (= () Select5864)) (cons read (cons (cons stinput ()) ())) (if (and (= input+ Select5863) (and (cons? Select5864) (= () (tl Select5864)))) (cons input+ (cons (hd Select5864) (cons (cons stinput ()) ()))) (if (and (= read-byte Select5863) (= () Select5864)) (shen.process-read-byte) (if (= prolog? Select5863) (shen.call-prolog Select5864) (if (and (= defprolog Select5863) (cons? Select5864)) (shen.compile-prolog (hd Select5864) (tl Select5864)) (if (and (= datatype Select5863) (cons? Select5864)) (shen.process-datatype (hd Select5864) (tl Select5864)) (if (= @s Select5863) (shen.process-@s V5861) (if (= synonyms Select5863) (shen.process-synonyms Select5864) (if (and (= nl Select5863) (= () Select5864)) (cons nl (cons 1 ())) (if (= let Select5863) (shen.process-let V5861) (if (= /. Select5863) (shen.process-lambda V5861) (if (= cases Select5863) (shen.process-cases V5861) (if (and (= time Select5863) (and (cons? Select5864) (= () (tl Select5864)))) (shen.process-time (hd Select5864)) (if (and (= put Select5863) (and (cons? Select5864) (and (cons? (tl Select5864)) (and (cons? (tl (tl Select5864))) (= () (tl (tl (tl Select5864)))))))) (cons put (cons (hd Select5864) (cons (hd (tl Select5864)) (cons (hd (tl (tl Select5864))) (cons (cons value (cons *property-vector* ())) ()))))) (if (and (= get Select5863) (and (cons? Select5864) (and (cons? (tl Select5864)) (= () (tl (tl Select5864)))))) (cons get (cons (hd Select5864) (cons (hd (tl Select5864)) (cons (cons value (cons *property-vector* ())) ())))) (if (and (= unput Select5863) (and (cons? Select5864) (and (cons? (tl Select5864)) (= () (tl (tl Select5864)))))) (cons unput (cons (hd Select5864) (cons (hd (tl Select5864)) (cons (cons value (cons *property-vector* ())) ())))) (if (and (cons? Select5864) (and (cons? (tl Select5864)) (and (cons? (tl (tl Select5864))) (element? Select5863 (cons @p (cons @v (cons append (cons and (cons or (cons + (cons * (cons do ())))))))))))) (cons Select5863 (cons (hd Select5864) (cons (shen.process-assoc (cons Select5863 (tl Select5864))) ()))) (thaw GoTo5862))))))))))))))))))))))))))))) (thaw GoTo5862))))

(defun shen.process-def (V5865 V5866) (let W5867 (cons X (cons -> (cons X ()))) (let W5868 (eval (cons define (cons V5865 (append V5866 W5867)))) (let W5869 (shen.record-macro V5865 (fn V5865)) V5865))))

(defun shen.process-let (V5870) (if (and (cons? V5870) (and (= let (hd V5870)) (and (cons? (tl V5870)) (and (cons? (tl (tl V5870))) (and (cons? (tl (tl (tl V5870)))) (cons? (tl (tl (tl (tl V5870)))))))))) (cons let (cons (hd (tl V5870)) (cons (hd (tl (tl V5870))) (cons (cons let (tl (tl (tl V5870)))) ())))) V5870))

(defun shen.process-@s (V5871) (let GoTo5873 (freeze V5871) (if (cons? V5871) (let Select5880 (tl V5871) (if (= @s (hd V5871)) (if (cons? Select5880) (let Select5878 (hd Select5880) (let Select5879 (tl Select5880) (if (cons? Select5879) (let Select5877 (tl Select5879) (if (cons? Select5877) (cons @s (cons Select5878 (cons (shen.process-@s (cons @s Select5879)) ()))) (if (and (= () Select5877) (string? Select5878)) (let W5872 (explode Select5878) (if (> (length W5872) 1) (shen.process-@s (cons @s (append W5872 Select5879))) V5871)) (thaw GoTo5873)))) (thaw GoTo5873)))) (thaw GoTo5873)) (thaw GoTo5873))) (thaw GoTo5873))))

(defun shen.process-datatype (V5881 V5882) (let W5883 (shen.intern-type V5881) (let W5884 (compile (lambda Z5885 (shen.<datatype> Z5885)) (cons W5883 V5882)) W5883)))

(defun shen.intern-type (V5886) (intern (cn (str V5886) "#type")))

(defun shen.process-synonyms (V5887) (shen.synonyms-h (set shen.*synonyms* (append V5887 (value shen.*synonyms*)))))

(defun shen.synonyms-h (V5888) (let W5889 (map (lambda Z5890 (shen.curry-type Z5890)) V5888) (let W5891 (eval (cons define (cons shen.demod (shen.compile-synonyms W5889)))) synonyms)))

(defun shen.compile-synonyms (V5894) (if (= () V5894) (let W5895 (gensym X) (cons W5895 (cons -> (cons W5895 ())))) (if (and (cons? V5894) (cons? (tl V5894))) (cons (shen.rcons_form (hd V5894)) (cons -> (cons (shen.rcons_form (hd (tl V5894))) (shen.compile-synonyms (tl (tl V5894)))))) (simple-error "synonyms requires an even number of arguments
"))))

(defun shen.process-lambda (V5896) (let GoTo5897 (freeze V5896) (if (cons? V5896) (let Select5904 (tl V5896) (if (= /. (hd V5896)) (if (cons? Select5904) (let Select5902 (hd Select5904) (let Select5903 (tl Select5904) (if (cons? Select5903) (let Select5901 (tl Select5903) (if (cons? Select5901) (cons lambda (cons Select5902 (cons (shen.process-lambda (cons /. Select5903)) ()))) (if (= () Select5901) (if (variable? Select5902) (cons lambda Select5904) (simple-error (shen.app Select5902 " is not a variable
" shen.s))) (thaw GoTo5897)))) (thaw GoTo5897)))) (thaw GoTo5897)) (thaw GoTo5897))) (thaw GoTo5897))))

(defun shen.process-cases (V5907) (let GoTo5908 (freeze V5907) (if (cons? V5907) (let Select5916 (tl V5907) (if (= cases (hd V5907)) (if (cons? Select5916) (let Select5914 (hd Select5916) (let Select5915 (tl Select5916) (if (and (= true Select5914) (cons? Select5915)) (hd Select5915) (let GoTo5911 (freeze (if (= () Select5915) (simple-error "error: odd number of case elements
") (thaw GoTo5908))) (if (cons? Select5915) (let Select5912 (hd Select5915) (let Select5913 (tl Select5915) (if (= () Select5913) (cons if (cons Select5914 (cons Select5912 (cons (cons simple-error (cons "error: cases exhausted" ())) ())))) (cons if (cons Select5914 (cons Select5912 (cons (shen.process-cases (cons cases Select5913)) ()))))))) (thaw GoTo5911)))))) (thaw GoTo5908)) (thaw GoTo5908))) (thaw GoTo5908))))

(defun shen.process-time (V5917) (cons let (cons Start (cons (cons get-time (cons run ())) (cons Result (cons V5917 (cons Finish (cons (cons get-time (cons run ())) (cons Time (cons (cons - (cons Finish (cons Start ()))) (cons Message (cons (cons pr (cons (cons cn (cons "
run time: " (cons (cons cn (cons (cons str (cons Time ())) (cons " secs
" ()))) ()))) (cons (cons stoutput ()) ()))) (cons Result ())))))))))))))

(defun shen.process-assoc (V5918) (if (and (cons? V5918) (and (cons? (tl V5918)) (and (cons? (tl (tl V5918))) (cons? (tl (tl (tl V5918))))))) (cons (hd V5918) (cons (hd (tl V5918)) (cons (cons (hd V5918) (tl (tl V5918))) ()))) V5918))

(defun shen.make-uppercase (V5919) (intern (shen.mu-h (str V5919))))

(defun shen.mu-h (V5920) (if (= "" V5920) "" (if (shen.+string? V5920) (let W5921 (string->n (hdstr V5920)) (let W5922 (- W5921 32) (let W5923 (if (and (>= W5921 97) (<= W5921 122)) (n->string W5922) (hdstr V5920)) (@s W5923 (shen.mu-h (tlstr V5920)))))) (simple-error "partial function shen.mu-h"))))

(defun shen.record-macro (V5924 V5925) (set *macros* (shen.update-assoc V5924 V5925 (value *macros*))))

(defun shen.update-assoc (V5935 V5936 V5937) (if (= () V5937) (cons (cons V5935 V5936) ()) (let GoTo5938 (freeze (simple-error "implementation error in shen.update-assoc")) (if (cons? V5937) (let Select5939 (hd V5937) (let Select5940 (tl V5937) (if (and (cons? Select5939) (= V5935 (hd Select5939))) (cons (cons (hd Select5939) V5936) Select5940) (cons Select5939 (shen.update-assoc V5935 V5936 Select5940))))) (thaw GoTo5938)))))

(defun shen.process-read-byte () (if (shen.char-stinput? (stinput)) (cons string->n (cons (cons shen.read-unit-string (cons (cons stinput ()) ())) ())) (cons read-byte (cons (cons stinput ()) ()))))

(defun shen.call-prolog (V5941) (let W5942 (cons shen.prolog-vector ()) (let W5943 (cons @v (cons true (cons 0 (cons (cons vector (cons 0 ())) ())))) (let W5944 0 (let W5945 (cons freeze (cons true ())) (let W5946 (compile (lambda Z5947 (shen.<body> Z5947)) V5941) (let W5948 (shen.received V5941) (let W5949 (gensym V) (let W5950 (gensym L) (let W5951 (gensym K) (let W5952 (gensym C) (let W5953 (cons lambda (cons W5949 (cons (cons lambda (cons W5950 (cons (cons lambda (cons W5951 (cons (cons lambda (cons W5952 (cons (shen.continue W5948 W5946 W5949 W5950 W5951 W5952) ()))) ()))) ()))) ()))) (cons W5953 (cons W5942 (cons W5943 (cons W5944 (cons W5945 ())))))))))))))))))

(defun shen.received (V5956) (let GoTo5957 (freeze ()) (if (cons? V5956) (let Select5958 (hd V5956) (let Select5959 (tl V5956) (if (and (= receive Select5958) (and (cons? Select5959) (= () (tl Select5959)))) Select5959 (union (shen.received Select5958) (shen.received Select5959))))) (thaw GoTo5957))))

(defun shen.prolog-vector () (let W5960 (absvector (value shen.*prolog-memory*)) (let W5961 (address-> W5960 0 shen.print-prolog-vector) (let W5962 (address-> W5960 1 2) W5962))))

(defun receive (V5963) V5963)

(defun shen.rcons_form (V5964) (if (cons? V5964) (cons cons (cons (shen.rcons_form (hd V5964)) (cons (shen.rcons_form (tl V5964)) ()))) V5964))

(defun shen.tuple-up (V5965) (if (cons? V5965) (cons @p (cons (hd V5965) (cons (shen.tuple-up (tl V5965)) ()))) V5965))

(defun undefmacro (V5966) (do (set *macros* (remove (assoc V5966 (value *macros*)) (value *macros*))) V5966))

