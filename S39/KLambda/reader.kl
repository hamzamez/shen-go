(defun read-file (V2162) (let W2163 (read-file-as-bytelist V2162) (let W2164 (shen.compileBytes (lambda Z2165 (shen.<s-exprs> Z2165)) W2163) (let W2166 (shen.process-sexprs W2164) W2166))))

(defun shen.compileBytes (V2167 V2168) (let W2169 (V2167 V2168) (if (shen.parse-failure? W2169) (simple-error "parse failure
") (if (cons? (shen.in-> W2169)) (shen.print-residue (shen.in-> W2169)) (shen.<-out W2169)))))

(defun shen.print-residue (V2170) (let W2171 (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V2170)))

(defun shen.nchars (V2176 V2177) (cond ((= 0 V2176) (do (pr " ..." (stoutput)) (abort))) ((= () V2177) (do (pr " ..." (stoutput)) (abort))) ((cons? V2177) (do (pr (n->string (hd V2177)) (stoutput)) (shen.nchars (- V2176 1) (tl V2177)))) (true (simple-error "partial function shen.nchars"))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V2178) (let W2179 (open V2178 in) (let W2180 (read-byte W2179) (let W2181 (shen.read-file-as-bytelist-help W2179 W2180 ()) (let W2182 (close W2179) (reverse W2181))))))

(defun shen.read-file-as-bytelist-help (V2183 V2184 V2185) (cond ((= -1 V2184) V2185) (true (shen.read-file-as-bytelist-help V2183 (read-byte V2183) (cons V2184 V2185)))))

(defun read-file-as-string (V2186) (let W2187 (open V2186 in) (shen.rfas-h W2187 (read-byte W2187) "")))

(defun shen.rfas-h (V2188 V2189 V2190) (cond ((= -1 V2189) (do (close V2188) V2190)) (true (shen.rfas-h V2188 (read-byte V2188) (cn V2190 (n->string V2189))))))

(defun input (V2191) (eval-kl (read V2191)))

(defun input+ (V2192 V2193) (let W2194 (shen.monotype V2192) (let W2195 (read V2193) (if (= false (shen.typecheck W2195 (shen.rectify-type V2192))) (simple-error (cn "type error: " (shen.app W2195 (cn " is not of type " (shen.app V2192 "
" shen.r)) shen.r))) (eval-kl W2195)))))

(defun shen.monotype (V2196) (cond ((cons? V2196) (map (lambda Z2197 (shen.monotype Z2197)) V2196)) (true (if (variable? V2196) (simple-error (cn "input+ expects a monotype: not " (shen.app V2196 "
" shen.a))) V2196))))

(defun lineread (V2198) (shen.read-loop V2198 (shen.my-read-byte V2198) () (lambda Z2199 (shen.return? Z2199))))

(defun read-from-string (V2200) (let W2201 (shen.str->bytes V2200) (let W2202 (compile (lambda Z2203 (shen.<s-exprs> Z2203)) W2201) (let W2204 (shen.process-sexprs W2202) W2204))))

(defun read-from-string-unprocessed (V2205) (let W2206 (shen.str->bytes V2205) (let W2207 (compile (lambda Z2208 (shen.<s-exprs> Z2208)) W2206) W2207)))

(defun shen.str->bytes (V2209) (cond ((= "" V2209) ()) ((shen.+string? V2209) (cons (string->n (hdstr V2209)) (shen.str->bytes (tlstr V2209)))) (true (simple-error "partial function shen.str->bytes"))))

(defun read (V2210) (hd (shen.read-loop V2210 (shen.my-read-byte V2210) () (lambda Z2211 (shen.whitespace? Z2211)))))

(defun shen.my-read-byte (V2212) (if (shen.char-stinput? V2212) (string->n (shen.read-unit-string V2212)) (read-byte V2212)))

(defun shen.read-loop (V2217 V2218 V2219 V2220) (cond ((= 94 V2218) (simple-error "read aborted")) ((= -1 V2218) (if (empty? V2219) (simple-error "error: empty stream") (compile (lambda Z2221 (shen.<s-exprs> Z2221)) V2219))) ((= 0 V2218) (shen.read-loop V2217 (shen.my-read-byte V2217) V2219 V2220)) (true (if (V2220 V2218) (let W2222 (shen.try-parse V2219) (if (shen.nothing-doing? W2222) (shen.read-loop V2217 (shen.my-read-byte V2217) (append V2219 (cons V2218 ())) V2220) (do (shen.record-it V2219) W2222))) (shen.read-loop V2217 (shen.my-read-byte V2217) (append V2219 (cons V2218 ())) V2220)))))

(defun shen.try-parse (V2223) (let W2224 (trap-error (compile (lambda Z2225 (shen.<s-exprs> Z2225)) V2223) (lambda Z2226 shen.i-failed!)) (if (shen.nothing-doing? W2224) shen.i-failed! (shen.process-sexprs W2224))))

(defun shen.nothing-doing? (V2229) (cond ((= shen.i-failed! V2229) true) ((= () V2229) true) (true false)))

(defun shen.record-it (V2230) (set shen.*it* (shen.bytes->string V2230)))

(defun shen.bytes->string (V2231) (cond ((= () V2231) "") ((cons? V2231) (cn (n->string (hd V2231)) (shen.bytes->string (tl V2231)))) (true (simple-error "partial function shen.bytes->string"))))

(defun shen.process-sexprs (V2232) (let W2233 (shen.unpackage&macroexpand V2232) (let W2234 (shen.find-arities W2233) (let W2235 (shen.find-types W2233) (map (lambda Z2236 (shen.process-applications Z2236 W2235)) W2233)))))

(defun shen.find-types (V2237) (cond ((and (cons? V2237) (and (cons? (tl V2237)) (= (hd V2237) (intern ":")))) (cons (hd (tl V2237)) (shen.find-types (tl (tl V2237))))) ((cons? V2237) (append (shen.find-types (hd V2237)) (shen.find-types (tl V2237)))) (true ())))

(defun shen.find-arities (V2240) (cond ((and (cons? V2240) (and (= define (hd V2240)) (and (cons? (tl V2240)) (and (cons? (tl (tl V2240))) (= { (hd (tl (tl V2240)))))))) (shen.store-arity (hd (tl V2240)) (shen.find-arity (hd (tl V2240)) 1 (tl (tl (tl V2240)))))) ((and (cons? V2240) (and (= define (hd V2240)) (cons? (tl V2240)))) (shen.store-arity (hd (tl V2240)) (shen.find-arity (hd (tl V2240)) 0 (tl (tl V2240))))) ((cons? V2240) (map (lambda Z2241 (shen.find-arities Z2241)) V2240)) (true shen.skip)))

(defun shen.store-arity (V2242 V2243) (let W2244 (arity V2242) (if (= W2244 -1) (shen.execute-store-arity V2242 V2243) (if (= W2244 V2243) shen.skip (if (shen.sysfunc? V2242) (simple-error (shen.app V2242 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V2242 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V2242 V2243)))))))

(defun shen.execute-store-arity (V2245 V2246) (cond ((= 0 V2246) (put V2245 arity 0 (value *property-vector*))) (true (do (put V2245 arity V2246 (value *property-vector*)) (shen.update-lambdatable V2245 V2246)))))

(defun shen.update-lambdatable (V2247 V2248) (let W2249 (value shen.*lambdatable*) (let W2250 (eval-kl (shen.lambda-function (cons V2247 ()) V2248)) (let W2251 (shen.assoc-> V2247 W2250 W2249) (let W2252 (set shen.*lambdatable* W2251) W2252)))))

(defun shen.lambda-function (V2255 V2256) (cond ((= 0 V2256) shen.skip) ((= 1 V2256) (let W2257 (gensym Y) (cons lambda (cons W2257 (cons (append V2255 (cons W2257 ())) ()))))) (true (let W2258 (gensym Y) (cons lambda (cons W2258 (cons (shen.lambda-function (append V2255 (cons W2258 ())) (- V2256 1)) ())))))))

(defun shen.assoc-> (V2268 V2269 V2270) (cond ((= () V2270) (cons (cons V2268 V2269) ())) ((and (cons? V2270) (and (cons? (hd V2270)) (= V2268 (hd (hd V2270))))) (cons (cons (hd (hd V2270)) V2269) (tl V2270))) ((cons? V2270) (cons (hd V2270) (shen.assoc-> V2268 V2269 (tl V2270)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V2285 V2286 V2287) (cond ((and (= 0 V2286) (and (cons? V2287) (= (hd V2287) ->))) 0) ((and (= 0 V2286) (and (cons? V2287) (= (hd V2287) <-))) 0) ((and (= 0 V2286) (cons? V2287)) (+ 1 (shen.find-arity V2285 0 (tl V2287)))) ((and (= 1 V2286) (and (cons? V2287) (= } (hd V2287)))) (shen.find-arity V2285 0 (tl V2287))) ((and (= 1 V2286) (cons? V2287)) (shen.find-arity V2285 1 (tl V2287))) ((= 1 V2286) (simple-error (cn "syntax error in " (shen.app V2285 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V2285 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V2288) (let W2289 (let W2290 (shen.<lsb> V2288) (if (shen.parse-failure? W2290) (shen.parse-failure) (let W2291 (shen.in-> W2290) (let W2292 (shen.<s-exprs1> W2291) (if (shen.parse-failure? W2292) (shen.parse-failure) (let W2293 (shen.<-out W2292) (let W2294 (shen.in-> W2292) (let W2295 (shen.<rsb> W2294) (if (shen.parse-failure? W2295) (shen.parse-failure) (let W2296 (shen.in-> W2295) (let W2297 (shen.<s-exprs2> W2296) (if (shen.parse-failure? W2297) (shen.parse-failure) (let W2298 (shen.<-out W2297) (let W2299 (shen.in-> W2297) (shen.comb W2299 (cons (shen.cons-form W2293) W2298)))))))))))))))) (if (shen.parse-failure? W2289) (let W2300 (let W2301 (shen.<lrb> V2288) (if (shen.parse-failure? W2301) (shen.parse-failure) (let W2302 (shen.in-> W2301) (let W2303 (shen.<s-exprs1> W2302) (if (shen.parse-failure? W2303) (shen.parse-failure) (let W2304 (shen.<-out W2303) (let W2305 (shen.in-> W2303) (let W2306 (shen.<rrb> W2305) (if (shen.parse-failure? W2306) (shen.parse-failure) (let W2307 (shen.in-> W2306) (let W2308 (shen.<s-exprs2> W2307) (if (shen.parse-failure? W2308) (shen.parse-failure) (let W2309 (shen.<-out W2308) (let W2310 (shen.in-> W2308) (shen.comb W2310 (shen.add-sexpr W2304 W2309)))))))))))))))) (if (shen.parse-failure? W2300) (let W2311 (let W2312 (shen.<lcurly> V2288) (if (shen.parse-failure? W2312) (shen.parse-failure) (let W2313 (shen.in-> W2312) (let W2314 (shen.<s-exprs> W2313) (if (shen.parse-failure? W2314) (shen.parse-failure) (let W2315 (shen.<-out W2314) (let W2316 (shen.in-> W2314) (shen.comb W2316 (cons { W2315))))))))) (if (shen.parse-failure? W2311) (let W2317 (let W2318 (shen.<rcurly> V2288) (if (shen.parse-failure? W2318) (shen.parse-failure) (let W2319 (shen.in-> W2318) (let W2320 (shen.<s-exprs> W2319) (if (shen.parse-failure? W2320) (shen.parse-failure) (let W2321 (shen.<-out W2320) (let W2322 (shen.in-> W2320) (shen.comb W2322 (cons } W2321))))))))) (if (shen.parse-failure? W2317) (let W2323 (let W2324 (shen.<bar> V2288) (if (shen.parse-failure? W2324) (shen.parse-failure) (let W2325 (shen.in-> W2324) (let W2326 (shen.<s-exprs> W2325) (if (shen.parse-failure? W2326) (shen.parse-failure) (let W2327 (shen.<-out W2326) (let W2328 (shen.in-> W2326) (shen.comb W2328 (cons bar! W2327))))))))) (if (shen.parse-failure? W2323) (let W2329 (let W2330 (shen.<semicolon> V2288) (if (shen.parse-failure? W2330) (shen.parse-failure) (let W2331 (shen.in-> W2330) (let W2332 (shen.<s-exprs> W2331) (if (shen.parse-failure? W2332) (shen.parse-failure) (let W2333 (shen.<-out W2332) (let W2334 (shen.in-> W2332) (shen.comb W2334 (cons (intern ";") W2333))))))))) (if (shen.parse-failure? W2329) (let W2335 (let W2336 (shen.<colon> V2288) (if (shen.parse-failure? W2336) (shen.parse-failure) (let W2337 (shen.in-> W2336) (let W2338 (shen.<equal> W2337) (if (shen.parse-failure? W2338) (shen.parse-failure) (let W2339 (shen.in-> W2338) (let W2340 (shen.<s-exprs> W2339) (if (shen.parse-failure? W2340) (shen.parse-failure) (let W2341 (shen.<-out W2340) (let W2342 (shen.in-> W2340) (shen.comb W2342 (cons (intern ":=") W2341)))))))))))) (if (shen.parse-failure? W2335) (let W2343 (let W2344 (shen.<colon> V2288) (if (shen.parse-failure? W2344) (shen.parse-failure) (let W2345 (shen.in-> W2344) (let W2346 (shen.<s-exprs> W2345) (if (shen.parse-failure? W2346) (shen.parse-failure) (let W2347 (shen.<-out W2346) (let W2348 (shen.in-> W2346) (shen.comb W2348 (cons (intern ":") W2347))))))))) (if (shen.parse-failure? W2343) (let W2349 (let W2350 (shen.<comma> V2288) (if (shen.parse-failure? W2350) (shen.parse-failure) (let W2351 (shen.in-> W2350) (let W2352 (shen.<s-exprs> W2351) (if (shen.parse-failure? W2352) (shen.parse-failure) (let W2353 (shen.<-out W2352) (let W2354 (shen.in-> W2352) (shen.comb W2354 (cons (intern ",") W2353))))))))) (if (shen.parse-failure? W2349) (let W2355 (let W2356 (shen.<comment> V2288) (if (shen.parse-failure? W2356) (shen.parse-failure) (let W2357 (shen.in-> W2356) (let W2358 (shen.<s-exprs> W2357) (if (shen.parse-failure? W2358) (shen.parse-failure) (let W2359 (shen.<-out W2358) (let W2360 (shen.in-> W2358) (shen.comb W2360 W2359)))))))) (if (shen.parse-failure? W2355) (let W2361 (let W2362 (shen.<atom> V2288) (if (shen.parse-failure? W2362) (shen.parse-failure) (let W2363 (shen.<-out W2362) (let W2364 (shen.in-> W2362) (let W2365 (shen.<s-exprs> W2364) (if (shen.parse-failure? W2365) (shen.parse-failure) (let W2366 (shen.<-out W2365) (let W2367 (shen.in-> W2365) (shen.comb W2367 (cons W2363 W2366)))))))))) (if (shen.parse-failure? W2361) (let W2368 (let W2369 (shen.<whitespaces> V2288) (if (shen.parse-failure? W2369) (shen.parse-failure) (let W2370 (shen.in-> W2369) (let W2371 (shen.<s-exprs> W2370) (if (shen.parse-failure? W2371) (shen.parse-failure) (let W2372 (shen.<-out W2371) (let W2373 (shen.in-> W2371) (shen.comb W2373 W2372)))))))) (if (shen.parse-failure? W2368) (let W2374 (let W2375 (<e> V2288) (if (shen.parse-failure? W2375) (shen.parse-failure) (let W2376 (shen.in-> W2375) (shen.comb W2376 ())))) (if (shen.parse-failure? W2374) (shen.parse-failure) W2374)) W2368)) W2361)) W2355)) W2349)) W2343)) W2335)) W2329)) W2323)) W2317)) W2311)) W2300)) W2289)))

(defun shen.add-sexpr (V2377 V2378) (cond ((and (cons? V2377) (and (= $ (hd V2377)) (and (cons? (tl V2377)) (= () (tl (tl V2377)))))) (append (explode (hd (tl V2377))) V2378)) (true (cons V2377 V2378))))

(defun shen.<lsb> (V2379) (let W2380 (if (shen.hds=? V2379 91) (let W2381 (tail V2379) (shen.comb W2381 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2380) (shen.parse-failure) W2380)))

(defun shen.<rsb> (V2382) (let W2383 (if (shen.hds=? V2382 93) (let W2384 (tail V2382) (shen.comb W2384 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2383) (shen.parse-failure) W2383)))

(defun shen.<s-exprs1> (V2385) (let W2386 (let W2387 (shen.<s-exprs> V2385) (if (shen.parse-failure? W2387) (shen.parse-failure) (let W2388 (shen.<-out W2387) (let W2389 (shen.in-> W2387) (shen.comb W2389 W2388))))) (if (shen.parse-failure? W2386) (shen.parse-failure) W2386)))

(defun shen.<s-exprs2> (V2390) (let W2391 (let W2392 (shen.<s-exprs> V2390) (if (shen.parse-failure? W2392) (shen.parse-failure) (let W2393 (shen.<-out W2392) (let W2394 (shen.in-> W2392) (shen.comb W2394 W2393))))) (if (shen.parse-failure? W2391) (shen.parse-failure) W2391)))

(defun shen.cons-form (V2396) (cond ((= () V2396) ()) ((and (cons? V2396) (and (cons? (tl V2396)) (and (cons? (tl (tl V2396))) (and (= () (tl (tl (tl V2396)))) (= (hd (tl V2396)) bar!))))) (cons cons (cons (hd V2396) (tl (tl V2396))))) ((and (cons? V2396) (and (cons? (tl V2396)) (and (cons? (tl (tl V2396))) (and (cons? (tl (tl (tl V2396)))) (= (hd (tl V2396)) bar!))))) (simple-error "misapplication of |
")) ((cons? V2396) (cons cons (cons (hd V2396) (cons (shen.cons-form (tl V2396)) ())))) (true (simple-error "partial function shen.cons-form"))))

(defun shen.<lrb> (V2397) (let W2398 (if (shen.hds=? V2397 40) (let W2399 (tail V2397) (shen.comb W2399 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2398) (shen.parse-failure) W2398)))

(defun shen.<rrb> (V2400) (let W2401 (if (shen.hds=? V2400 41) (let W2402 (tail V2400) (shen.comb W2402 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2401) (shen.parse-failure) W2401)))

(defun shen.<lcurly> (V2403) (let W2404 (if (shen.hds=? V2403 123) (let W2405 (tail V2403) (shen.comb W2405 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2404) (shen.parse-failure) W2404)))

(defun shen.<rcurly> (V2406) (let W2407 (if (shen.hds=? V2406 125) (let W2408 (tail V2406) (shen.comb W2408 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2407) (shen.parse-failure) W2407)))

(defun shen.<bar> (V2409) (let W2410 (if (shen.hds=? V2409 124) (let W2411 (tail V2409) (shen.comb W2411 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2410) (shen.parse-failure) W2410)))

(defun shen.<semicolon> (V2412) (let W2413 (if (shen.hds=? V2412 59) (let W2414 (tail V2412) (shen.comb W2414 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2413) (shen.parse-failure) W2413)))

(defun shen.<colon> (V2415) (let W2416 (if (shen.hds=? V2415 58) (let W2417 (tail V2415) (shen.comb W2417 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2416) (shen.parse-failure) W2416)))

(defun shen.<comma> (V2418) (let W2419 (if (shen.hds=? V2418 44) (let W2420 (tail V2418) (shen.comb W2420 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2419) (shen.parse-failure) W2419)))

(defun shen.<equal> (V2421) (let W2422 (if (shen.hds=? V2421 61) (let W2423 (tail V2421) (shen.comb W2423 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2422) (shen.parse-failure) W2422)))

(defun shen.<comment> (V2424) (let W2425 (let W2426 (shen.<singleline> V2424) (if (shen.parse-failure? W2426) (shen.parse-failure) (let W2427 (shen.in-> W2426) (shen.comb W2427 shen.skip)))) (if (shen.parse-failure? W2425) (let W2428 (let W2429 (shen.<multiline> V2424) (if (shen.parse-failure? W2429) (shen.parse-failure) (let W2430 (shen.in-> W2429) (shen.comb W2430 shen.skip)))) (if (shen.parse-failure? W2428) (shen.parse-failure) W2428)) W2425)))

(defun shen.<singleline> (V2431) (let W2432 (let W2433 (shen.<backslash> V2431) (if (shen.parse-failure? W2433) (shen.parse-failure) (let W2434 (shen.in-> W2433) (let W2435 (shen.<backslash> W2434) (if (shen.parse-failure? W2435) (shen.parse-failure) (let W2436 (shen.in-> W2435) (let W2437 (shen.<shortnatters> W2436) (if (shen.parse-failure? W2437) (shen.parse-failure) (let W2438 (shen.in-> W2437) (let W2439 (shen.<returns> W2438) (if (shen.parse-failure? W2439) (shen.parse-failure) (let W2440 (shen.in-> W2439) (shen.comb W2440 shen.skip))))))))))))) (if (shen.parse-failure? W2432) (shen.parse-failure) W2432)))

(defun shen.<backslash> (V2441) (let W2442 (if (shen.hds=? V2441 92) (let W2443 (tail V2441) (shen.comb W2443 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2442) (shen.parse-failure) W2442)))

(defun shen.<shortnatters> (V2444) (let W2445 (let W2446 (shen.<shortnatter> V2444) (if (shen.parse-failure? W2446) (shen.parse-failure) (let W2447 (shen.in-> W2446) (let W2448 (shen.<shortnatters> W2447) (if (shen.parse-failure? W2448) (shen.parse-failure) (let W2449 (shen.in-> W2448) (shen.comb W2449 shen.skip))))))) (if (shen.parse-failure? W2445) (let W2450 (let W2451 (<e> V2444) (if (shen.parse-failure? W2451) (shen.parse-failure) (let W2452 (shen.in-> W2451) (shen.comb W2452 shen.skip)))) (if (shen.parse-failure? W2450) (shen.parse-failure) W2450)) W2445)))

(defun shen.<shortnatter> (V2453) (let W2454 (if (cons? V2453) (let W2455 (head V2453) (let W2456 (tail V2453) (if (not (shen.return? W2455)) (shen.comb W2456 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2454) (shen.parse-failure) W2454)))

(defun shen.<returns> (V2457) (let W2458 (let W2459 (shen.<return> V2457) (if (shen.parse-failure? W2459) (shen.parse-failure) (let W2460 (shen.in-> W2459) (let W2461 (shen.<returns> W2460) (if (shen.parse-failure? W2461) (shen.parse-failure) (let W2462 (shen.in-> W2461) (shen.comb W2462 shen.skip))))))) (if (shen.parse-failure? W2458) (let W2463 (let W2464 (shen.<return> V2457) (if (shen.parse-failure? W2464) (shen.parse-failure) (let W2465 (shen.in-> W2464) (shen.comb W2465 shen.skip)))) (if (shen.parse-failure? W2463) (shen.parse-failure) W2463)) W2458)))

(defun shen.<return> (V2466) (let W2467 (if (cons? V2466) (let W2468 (head V2466) (let W2469 (tail V2466) (if (shen.return? W2468) (shen.comb W2469 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2467) (shen.parse-failure) W2467)))

(defun shen.return? (V2470) (element? V2470 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V2471) (let W2472 (let W2473 (shen.<backslash> V2471) (if (shen.parse-failure? W2473) (shen.parse-failure) (let W2474 (shen.in-> W2473) (let W2475 (shen.<times> W2474) (if (shen.parse-failure? W2475) (shen.parse-failure) (let W2476 (shen.in-> W2475) (let W2477 (shen.<longnatter> W2476) (if (shen.parse-failure? W2477) (shen.parse-failure) (let W2478 (shen.in-> W2477) (shen.comb W2478 shen.skip)))))))))) (if (shen.parse-failure? W2472) (shen.parse-failure) W2472)))

(defun shen.<times> (V2479) (let W2480 (if (shen.hds=? V2479 42) (let W2481 (tail V2479) (shen.comb W2481 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2480) (shen.parse-failure) W2480)))

(defun shen.<longnatter> (V2482) (let W2483 (let W2484 (shen.<comment> V2482) (if (shen.parse-failure? W2484) (shen.parse-failure) (let W2485 (shen.in-> W2484) (let W2486 (shen.<longnatter> W2485) (if (shen.parse-failure? W2486) (shen.parse-failure) (let W2487 (shen.in-> W2486) (shen.comb W2487 shen.skip))))))) (if (shen.parse-failure? W2483) (let W2488 (let W2489 (shen.<times> V2482) (if (shen.parse-failure? W2489) (shen.parse-failure) (let W2490 (shen.in-> W2489) (let W2491 (shen.<backslash> W2490) (if (shen.parse-failure? W2491) (shen.parse-failure) (let W2492 (shen.in-> W2491) (shen.comb W2492 shen.skip))))))) (if (shen.parse-failure? W2488) (let W2493 (if (cons? V2482) (let W2494 (tail V2482) (let W2495 (shen.<longnatter> W2494) (if (shen.parse-failure? W2495) (shen.parse-failure) (let W2496 (shen.in-> W2495) (shen.comb W2496 shen.skip))))) (shen.parse-failure)) (if (shen.parse-failure? W2493) (shen.parse-failure) W2493)) W2488)) W2483)))

(defun shen.<atom> (V2497) (let W2498 (let W2499 (shen.<str> V2497) (if (shen.parse-failure? W2499) (shen.parse-failure) (let W2500 (shen.<-out W2499) (let W2501 (shen.in-> W2499) (shen.comb W2501 W2500))))) (if (shen.parse-failure? W2498) (let W2502 (let W2503 (shen.<number> V2497) (if (shen.parse-failure? W2503) (shen.parse-failure) (let W2504 (shen.<-out W2503) (let W2505 (shen.in-> W2503) (shen.comb W2505 W2504))))) (if (shen.parse-failure? W2502) (let W2506 (let W2507 (shen.<sym> V2497) (if (shen.parse-failure? W2507) (shen.parse-failure) (let W2508 (shen.<-out W2507) (let W2509 (shen.in-> W2507) (shen.comb W2509 (if (= W2508 "<>") (cons vector (cons 0 ())) (intern W2508))))))) (if (shen.parse-failure? W2506) (shen.parse-failure) W2506)) W2502)) W2498)))

(defun shen.<sym> (V2510) (let W2511 (let W2512 (shen.<alpha> V2510) (if (shen.parse-failure? W2512) (shen.parse-failure) (let W2513 (shen.<-out W2512) (let W2514 (shen.in-> W2512) (let W2515 (shen.<alphanums> W2514) (if (shen.parse-failure? W2515) (shen.parse-failure) (let W2516 (shen.<-out W2515) (let W2517 (shen.in-> W2515) (shen.comb W2517 (cn W2513 W2516)))))))))) (if (shen.parse-failure? W2511) (shen.parse-failure) W2511)))

(defun shen.<alpha> (V2518) (let W2519 (if (cons? V2518) (let W2520 (head V2518) (let W2521 (tail V2518) (if (shen.alpha? W2520) (shen.comb W2521 (n->string W2520)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2519) (shen.parse-failure) W2519)))

(defun shen.alpha? (V2522) (or (shen.lowercase? V2522) (or (shen.uppercase? V2522) (shen.misc? V2522))))

(defun shen.lowercase? (V2523) (and (>= V2523 97) (<= V2523 122)))

(defun shen.uppercase? (V2524) (and (>= V2524 65) (<= V2524 90)))

(defun shen.misc? (V2525) (element? V2525 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V2526) (let W2527 (let W2528 (shen.<alphanum> V2526) (if (shen.parse-failure? W2528) (shen.parse-failure) (let W2529 (shen.<-out W2528) (let W2530 (shen.in-> W2528) (let W2531 (shen.<alphanums> W2530) (if (shen.parse-failure? W2531) (shen.parse-failure) (let W2532 (shen.<-out W2531) (let W2533 (shen.in-> W2531) (shen.comb W2533 (cn W2529 W2532)))))))))) (if (shen.parse-failure? W2527) (let W2534 (let W2535 (<e> V2526) (if (shen.parse-failure? W2535) (shen.parse-failure) (let W2536 (shen.in-> W2535) (shen.comb W2536 "")))) (if (shen.parse-failure? W2534) (shen.parse-failure) W2534)) W2527)))

(defun shen.<alphanum> (V2537) (let W2538 (let W2539 (shen.<alpha> V2537) (if (shen.parse-failure? W2539) (shen.parse-failure) (let W2540 (shen.<-out W2539) (let W2541 (shen.in-> W2539) (shen.comb W2541 W2540))))) (if (shen.parse-failure? W2538) (let W2542 (let W2543 (shen.<numeral> V2537) (if (shen.parse-failure? W2543) (shen.parse-failure) (let W2544 (shen.<-out W2543) (let W2545 (shen.in-> W2543) (shen.comb W2545 W2544))))) (if (shen.parse-failure? W2542) (shen.parse-failure) W2542)) W2538)))

(defun shen.<numeral> (V2546) (let W2547 (if (cons? V2546) (let W2548 (head V2546) (let W2549 (tail V2546) (if (shen.digit? W2548) (shen.comb W2549 (n->string W2548)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2547) (shen.parse-failure) W2547)))

(defun shen.digit? (V2550) (and (>= V2550 48) (<= V2550 57)))

(defun shen.<str> (V2551) (let W2552 (let W2553 (shen.<dbq> V2551) (if (shen.parse-failure? W2553) (shen.parse-failure) (let W2554 (shen.in-> W2553) (let W2555 (shen.<strcontents> W2554) (if (shen.parse-failure? W2555) (shen.parse-failure) (let W2556 (shen.<-out W2555) (let W2557 (shen.in-> W2555) (let W2558 (shen.<dbq> W2557) (if (shen.parse-failure? W2558) (shen.parse-failure) (let W2559 (shen.in-> W2558) (shen.comb W2559 W2556))))))))))) (if (shen.parse-failure? W2552) (shen.parse-failure) W2552)))

(defun shen.<dbq> (V2560) (let W2561 (if (shen.hds=? V2560 34) (let W2562 (tail V2560) (shen.comb W2562 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2561) (shen.parse-failure) W2561)))

(defun shen.<strcontents> (V2563) (let W2564 (let W2565 (shen.<strc> V2563) (if (shen.parse-failure? W2565) (shen.parse-failure) (let W2566 (shen.<-out W2565) (let W2567 (shen.in-> W2565) (let W2568 (shen.<strcontents> W2567) (if (shen.parse-failure? W2568) (shen.parse-failure) (let W2569 (shen.<-out W2568) (let W2570 (shen.in-> W2568) (shen.comb W2570 (cn W2566 W2569)))))))))) (if (shen.parse-failure? W2564) (let W2571 (let W2572 (<e> V2563) (if (shen.parse-failure? W2572) (shen.parse-failure) (let W2573 (shen.in-> W2572) (shen.comb W2573 "")))) (if (shen.parse-failure? W2571) (shen.parse-failure) W2571)) W2564)))

(defun shen.<strc> (V2574) (let W2575 (let W2576 (shen.<control> V2574) (if (shen.parse-failure? W2576) (shen.parse-failure) (let W2577 (shen.<-out W2576) (let W2578 (shen.in-> W2576) (shen.comb W2578 W2577))))) (if (shen.parse-failure? W2575) (let W2579 (let W2580 (shen.<notdbq> V2574) (if (shen.parse-failure? W2580) (shen.parse-failure) (let W2581 (shen.<-out W2580) (let W2582 (shen.in-> W2580) (shen.comb W2582 W2581))))) (if (shen.parse-failure? W2579) (shen.parse-failure) W2579)) W2575)))

(defun shen.<control> (V2583) (let W2584 (let W2585 (shen.<lowC> V2583) (if (shen.parse-failure? W2585) (shen.parse-failure) (let W2586 (shen.in-> W2585) (let W2587 (shen.<hash> W2586) (if (shen.parse-failure? W2587) (shen.parse-failure) (let W2588 (shen.in-> W2587) (let W2589 (shen.<integer> W2588) (if (shen.parse-failure? W2589) (shen.parse-failure) (let W2590 (shen.<-out W2589) (let W2591 (shen.in-> W2589) (let W2592 (shen.<semicolon> W2591) (if (shen.parse-failure? W2592) (shen.parse-failure) (let W2593 (shen.in-> W2592) (shen.comb W2593 (n->string W2590))))))))))))))) (if (shen.parse-failure? W2584) (shen.parse-failure) W2584)))

(defun shen.<notdbq> (V2594) (let W2595 (if (cons? V2594) (let W2596 (head V2594) (let W2597 (tail V2594) (if (not (= W2596 34)) (shen.comb W2597 (n->string W2596)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2595) (shen.parse-failure) W2595)))

(defun shen.<lowC> (V2598) (let W2599 (if (shen.hds=? V2598 99) (let W2600 (tail V2598) (shen.comb W2600 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2599) (shen.parse-failure) W2599)))

(defun shen.<hash> (V2601) (let W2602 (if (shen.hds=? V2601 35) (let W2603 (tail V2601) (shen.comb W2603 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2602) (shen.parse-failure) W2602)))

(defun shen.<number> (V2604) (let W2605 (let W2606 (shen.<minus> V2604) (if (shen.parse-failure? W2606) (shen.parse-failure) (let W2607 (shen.in-> W2606) (let W2608 (shen.<number> W2607) (if (shen.parse-failure? W2608) (shen.parse-failure) (let W2609 (shen.<-out W2608) (let W2610 (shen.in-> W2608) (shen.comb W2610 (- 0 W2609))))))))) (if (shen.parse-failure? W2605) (let W2611 (let W2612 (shen.<plus> V2604) (if (shen.parse-failure? W2612) (shen.parse-failure) (let W2613 (shen.in-> W2612) (let W2614 (shen.<number> W2613) (if (shen.parse-failure? W2614) (shen.parse-failure) (let W2615 (shen.<-out W2614) (let W2616 (shen.in-> W2614) (shen.comb W2616 W2615)))))))) (if (shen.parse-failure? W2611) (let W2617 (let W2618 (shen.<e-number> V2604) (if (shen.parse-failure? W2618) (shen.parse-failure) (let W2619 (shen.<-out W2618) (let W2620 (shen.in-> W2618) (shen.comb W2620 W2619))))) (if (shen.parse-failure? W2617) (let W2621 (let W2622 (shen.<float> V2604) (if (shen.parse-failure? W2622) (shen.parse-failure) (let W2623 (shen.<-out W2622) (let W2624 (shen.in-> W2622) (shen.comb W2624 W2623))))) (if (shen.parse-failure? W2621) (let W2625 (let W2626 (shen.<integer> V2604) (if (shen.parse-failure? W2626) (shen.parse-failure) (let W2627 (shen.<-out W2626) (let W2628 (shen.in-> W2626) (shen.comb W2628 W2627))))) (if (shen.parse-failure? W2625) (shen.parse-failure) W2625)) W2621)) W2617)) W2611)) W2605)))

(defun shen.<minus> (V2629) (let W2630 (if (shen.hds=? V2629 45) (let W2631 (tail V2629) (shen.comb W2631 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2630) (shen.parse-failure) W2630)))

(defun shen.<plus> (V2632) (let W2633 (if (shen.hds=? V2632 43) (let W2634 (tail V2632) (shen.comb W2634 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2633) (shen.parse-failure) W2633)))

(defun shen.<integer> (V2635) (let W2636 (let W2637 (shen.<digits> V2635) (if (shen.parse-failure? W2637) (shen.parse-failure) (let W2638 (shen.<-out W2637) (let W2639 (shen.in-> W2637) (shen.comb W2639 (shen.compute-integer W2638)))))) (if (shen.parse-failure? W2636) (shen.parse-failure) W2636)))

(defun shen.<digits> (V2640) (let W2641 (let W2642 (shen.<digit> V2640) (if (shen.parse-failure? W2642) (shen.parse-failure) (let W2643 (shen.<-out W2642) (let W2644 (shen.in-> W2642) (let W2645 (shen.<digits> W2644) (if (shen.parse-failure? W2645) (shen.parse-failure) (let W2646 (shen.<-out W2645) (let W2647 (shen.in-> W2645) (shen.comb W2647 (cons W2643 W2646)))))))))) (if (shen.parse-failure? W2641) (let W2648 (let W2649 (shen.<digit> V2640) (if (shen.parse-failure? W2649) (shen.parse-failure) (let W2650 (shen.<-out W2649) (let W2651 (shen.in-> W2649) (shen.comb W2651 (cons W2650 ())))))) (if (shen.parse-failure? W2648) (shen.parse-failure) W2648)) W2641)))

(defun shen.<digit> (V2652) (let W2653 (if (cons? V2652) (let W2654 (head V2652) (let W2655 (tail V2652) (if (shen.digit? W2654) (shen.comb W2655 (shen.byte->digit W2654)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2653) (shen.parse-failure) W2653)))

(defun shen.byte->digit (V2656) (- V2656 48))

(defun shen.compute-integer (V2657) (shen.compute-integer-h (reverse V2657) 0))

(defun shen.compute-integer-h (V2660 V2661) (cond ((= () V2660) 0) ((cons? V2660) (+ (* (shen.expt 10 V2661) (hd V2660)) (shen.compute-integer-h (tl V2660) (+ V2661 1)))) (true (simple-error "partial function shen.compute-integer-h"))))

(defun shen.expt (V2664 V2665) (cond ((= 0 V2665) 1) ((> V2665 0) (* V2664 (shen.expt V2664 (- V2665 1)))) (true (/ (shen.expt V2664 (+ V2665 1)) V2664))))

(defun shen.<float> (V2666) (let W2667 (let W2668 (shen.<integer> V2666) (if (shen.parse-failure? W2668) (shen.parse-failure) (let W2669 (shen.<-out W2668) (let W2670 (shen.in-> W2668) (let W2671 (shen.<stop> W2670) (if (shen.parse-failure? W2671) (shen.parse-failure) (let W2672 (shen.in-> W2671) (let W2673 (shen.<fraction> W2672) (if (shen.parse-failure? W2673) (shen.parse-failure) (let W2674 (shen.<-out W2673) (let W2675 (shen.in-> W2673) (shen.comb W2675 (+ W2669 W2674))))))))))))) (if (shen.parse-failure? W2667) (let W2676 (let W2677 (shen.<stop> V2666) (if (shen.parse-failure? W2677) (shen.parse-failure) (let W2678 (shen.in-> W2677) (let W2679 (shen.<fraction> W2678) (if (shen.parse-failure? W2679) (shen.parse-failure) (let W2680 (shen.<-out W2679) (let W2681 (shen.in-> W2679) (shen.comb W2681 W2680)))))))) (if (shen.parse-failure? W2676) (shen.parse-failure) W2676)) W2667)))

(defun shen.<stop> (V2682) (let W2683 (if (shen.hds=? V2682 46) (let W2684 (tail V2682) (shen.comb W2684 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2683) (shen.parse-failure) W2683)))

(defun shen.<fraction> (V2685) (let W2686 (let W2687 (shen.<digits> V2685) (if (shen.parse-failure? W2687) (shen.parse-failure) (let W2688 (shen.<-out W2687) (let W2689 (shen.in-> W2687) (shen.comb W2689 (shen.compute-fraction W2688)))))) (if (shen.parse-failure? W2686) (shen.parse-failure) W2686)))

(defun shen.compute-fraction (V2690) (shen.compute-fraction-h V2690 -1))

(defun shen.compute-fraction-h (V2693 V2694) (cond ((= () V2693) 0) ((cons? V2693) (+ (* (shen.expt 10 V2694) (hd V2693)) (shen.compute-fraction-h (tl V2693) (- V2694 1)))) (true (simple-error "partial function shen.compute-fraction-h"))))

(defun shen.<e-number> (V2695) (let W2696 (let W2697 (shen.<float> V2695) (if (shen.parse-failure? W2697) (shen.parse-failure) (let W2698 (shen.<-out W2697) (let W2699 (shen.in-> W2697) (let W2700 (shen.<lowE> W2699) (if (shen.parse-failure? W2700) (shen.parse-failure) (let W2701 (shen.in-> W2700) (let W2702 (shen.<log10> W2701) (if (shen.parse-failure? W2702) (shen.parse-failure) (let W2703 (shen.<-out W2702) (let W2704 (shen.in-> W2702) (shen.comb W2704 (shen.compute-E W2698 W2703))))))))))))) (if (shen.parse-failure? W2696) (let W2705 (let W2706 (shen.<integer> V2695) (if (shen.parse-failure? W2706) (shen.parse-failure) (let W2707 (shen.<-out W2706) (let W2708 (shen.in-> W2706) (let W2709 (shen.<lowE> W2708) (if (shen.parse-failure? W2709) (shen.parse-failure) (let W2710 (shen.in-> W2709) (let W2711 (shen.<log10> W2710) (if (shen.parse-failure? W2711) (shen.parse-failure) (let W2712 (shen.<-out W2711) (let W2713 (shen.in-> W2711) (shen.comb W2713 (shen.compute-E W2707 W2712))))))))))))) (if (shen.parse-failure? W2705) (shen.parse-failure) W2705)) W2696)))

(defun shen.<log10> (V2714) (let W2715 (let W2716 (shen.<plus> V2714) (if (shen.parse-failure? W2716) (shen.parse-failure) (let W2717 (shen.in-> W2716) (let W2718 (shen.<log10> W2717) (if (shen.parse-failure? W2718) (shen.parse-failure) (let W2719 (shen.<-out W2718) (let W2720 (shen.in-> W2718) (shen.comb W2720 W2719)))))))) (if (shen.parse-failure? W2715) (let W2721 (let W2722 (shen.<minus> V2714) (if (shen.parse-failure? W2722) (shen.parse-failure) (let W2723 (shen.in-> W2722) (let W2724 (shen.<log10> W2723) (if (shen.parse-failure? W2724) (shen.parse-failure) (let W2725 (shen.<-out W2724) (let W2726 (shen.in-> W2724) (shen.comb W2726 (- 0 W2725))))))))) (if (shen.parse-failure? W2721) (let W2727 (let W2728 (shen.<integer> V2714) (if (shen.parse-failure? W2728) (shen.parse-failure) (let W2729 (shen.<-out W2728) (let W2730 (shen.in-> W2728) (shen.comb W2730 W2729))))) (if (shen.parse-failure? W2727) (shen.parse-failure) W2727)) W2721)) W2715)))

(defun shen.<lowE> (V2731) (let W2732 (if (shen.hds=? V2731 101) (let W2733 (tail V2731) (shen.comb W2733 shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? W2732) (shen.parse-failure) W2732)))

(defun shen.compute-E (V2734 V2735) (* V2734 (shen.expt 10 V2735)))

(defun shen.<whitespaces> (V2736) (let W2737 (let W2738 (shen.<whitespace> V2736) (if (shen.parse-failure? W2738) (shen.parse-failure) (let W2739 (shen.in-> W2738) (let W2740 (shen.<whitespaces> W2739) (if (shen.parse-failure? W2740) (shen.parse-failure) (let W2741 (shen.in-> W2740) (shen.comb W2741 shen.skip))))))) (if (shen.parse-failure? W2737) (let W2742 (let W2743 (shen.<whitespace> V2736) (if (shen.parse-failure? W2743) (shen.parse-failure) (let W2744 (shen.in-> W2743) (shen.comb W2744 shen.skip)))) (if (shen.parse-failure? W2742) (shen.parse-failure) W2742)) W2737)))

(defun shen.<whitespace> (V2745) (let W2746 (if (cons? V2745) (let W2747 (head V2745) (let W2748 (tail V2745) (if (shen.whitespace? W2747) (shen.comb W2748 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W2746) (shen.parse-failure) W2746)))

(defun shen.whitespace? (V2751) (cond ((= 32 V2751) true) ((= 13 V2751) true) ((= 10 V2751) true) ((= 9 V2751) true) (true false)))

(defun shen.unpackage&macroexpand (V2752) (cond ((= () V2752) ()) ((and (cons? V2752) (shen.packaged? (hd V2752))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V2752)) (tl V2752)))) ((cons? V2752) (let W2753 (macroexpand (hd V2752)) (if (shen.packaged? W2753) (shen.unpackage&macroexpand (cons W2753 (tl V2752))) (cons W2753 (shen.unpackage&macroexpand (tl V2752)))))) (true (simple-error "partial function shen.unpackage&macroexpand"))))

(defun shen.packaged? (V2756) (cond ((and (cons? V2756) (and (= package (hd V2756)) (and (cons? (tl V2756)) (cons? (tl (tl V2756)))))) true) (true false)))

(defun shen.unpackage (V2759) (cond ((and (cons? V2759) (and (= package (hd V2759)) (and (cons? (tl V2759)) (and (= null (hd (tl V2759))) (cons? (tl (tl V2759))))))) (tl (tl (tl V2759)))) ((and (cons? V2759) (and (= package (hd V2759)) (and (cons? (tl V2759)) (cons? (tl (tl V2759)))))) (let W2760 (eval (hd (tl (tl V2759)))) (let W2761 (shen.package-symbols (str (hd (tl V2759))) W2760 (tl (tl (tl V2759)))) (let W2762 (shen.record-external (hd (tl V2759)) W2760) (let W2763 (shen.record-internal (hd (tl V2759)) W2760 (tl (tl (tl V2759)))) W2761))))) (true (simple-error "partial function shen.unpackage"))))

(defun shen.record-internal (V2764 V2765 V2766) (let W2767 (trap-error (get V2764 shen.internal-symbols (value *property-vector*)) (lambda Z2768 ())) (let W2769 (shen.internal-symbols (str V2764) V2765 V2766) (put V2764 shen.internal-symbols (union W2769 W2767) (value *property-vector*)))))

(defun shen.internal-symbols (V2776 V2777 V2778) (cond ((cons? V2778) (union (shen.internal-symbols V2776 V2777 (hd V2778)) (shen.internal-symbols V2776 V2777 (tl V2778)))) ((shen.internal? V2778 V2776 V2777) (cons (shen.intern-in-package V2776 V2778) ())) (true ())))

(defun shen.record-external (V2779 V2780) (let W2781 (trap-error (get V2779 shen.external-symbols (value *property-vector*)) (lambda Z2782 ())) (put V2779 shen.external-symbols (union V2780 W2781) (value *property-vector*))))

(defun shen.package-symbols (V2787 V2788 V2789) (cond ((cons? V2789) (map (lambda Z2790 (shen.package-symbols V2787 V2788 Z2790)) V2789)) ((shen.internal? V2789 V2787 V2788) (shen.intern-in-package V2787 V2789)) (true V2789)))

(defun shen.intern-in-package (V2791 V2792) (intern (@s V2791 (@s "." (str V2792)))))

(defun shen.internal? (V2793 V2794 V2795) (and (not (element? V2793 V2795)) (and (not (shen.sng? V2793)) (and (not (shen.dbl? V2793)) (and (symbol? V2793) (and (not (shen.sysfunc? V2793)) (and (not (variable? V2793)) (and (not (shen.internal-to-shen? (str V2793))) (not (shen.internal-to-P? V2794 (str V2793)))))))))))

(defun shen.internal-to-shen? (V2800) (cond ((and (shen.+string? V2800) (and (= "s" (hdstr V2800)) (and (shen.+string? (tlstr V2800)) (and (= "h" (hdstr (tlstr V2800))) (and (shen.+string? (tlstr (tlstr V2800))) (and (= "e" (hdstr (tlstr (tlstr V2800)))) (and (shen.+string? (tlstr (tlstr (tlstr V2800)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V2800))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V2800))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V2800))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V2801) (element? V2801 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V2809 V2810) (cond ((and (= "" V2809) (and (shen.+string? V2810) (= "." (hdstr V2810)))) true) ((and (shen.+string? V2809) (and (shen.+string? V2810) (= (hdstr V2809) (hdstr V2810)))) (shen.internal-to-P? (tlstr V2809) (tlstr V2810))) (true false)))

(defun shen.process-applications (V2813 V2814) (cond ((element? V2813 V2814) V2813) ((and (cons? V2813) (shen.non-application? (hd V2813))) (shen.special-case (hd V2813) V2813 V2814)) ((cons? V2813) (shen.process-application (map (lambda Z2815 (shen.process-applications Z2815 V2814)) V2813) V2814)) (true V2813)))

(defun shen.non-application? (V2818) (cond ((= define V2818) true) ((= defun V2818) true) ((= synonyms V2818) true) ((shen.special? V2818) true) ((shen.extraspecial? V2818) true) (true false)))

(defun shen.special-case (V2823 V2824 V2825) (cond ((and (= lambda V2823) (and (cons? V2824) (and (= lambda (hd V2824)) (and (cons? (tl V2824)) (and (cons? (tl (tl V2824))) (= () (tl (tl (tl V2824))))))))) (cons lambda (cons (hd (tl V2824)) (cons (shen.process-applications (hd (tl (tl V2824))) V2825) ())))) ((and (= let V2823) (and (cons? V2824) (and (= let (hd V2824)) (and (cons? (tl V2824)) (and (cons? (tl (tl V2824))) (and (cons? (tl (tl (tl V2824)))) (= () (tl (tl (tl (tl V2824))))))))))) (cons let (cons (hd (tl V2824)) (cons (shen.process-applications (hd (tl (tl V2824))) V2825) (cons (shen.process-applications (hd (tl (tl (tl V2824)))) V2825) ()))))) ((and (= defun V2823) (and (cons? V2824) (and (= defun (hd V2824)) (and (cons? (tl V2824)) (and (cons? (tl (tl V2824))) (and (cons? (tl (tl (tl V2824)))) (= () (tl (tl (tl (tl V2824))))))))))) V2824) ((and (= define V2823) (and (cons? V2824) (and (= define (hd V2824)) (and (cons? (tl V2824)) (and (cons? (tl (tl V2824))) (= { (hd (tl (tl V2824))))))))) (cons define (cons (hd (tl V2824)) (cons { (shen.process-after-type (hd (tl V2824)) (tl (tl (tl V2824))) V2825))))) ((and (= define V2823) (and (cons? V2824) (and (= define (hd V2824)) (cons? (tl V2824))))) (cons define (cons (hd (tl V2824)) (map (lambda Z2826 (shen.process-applications Z2826 V2825)) (tl (tl V2824)))))) ((= synonyms V2823) (cons synonyms V2824)) ((and (= type V2823) (and (cons? V2824) (and (= type (hd V2824)) (and (cons? (tl V2824)) (and (cons? (tl (tl V2824))) (= () (tl (tl (tl V2824))))))))) (cons type (cons (shen.process-applications (hd (tl V2824)) V2825) (tl (tl V2824))))) ((and (= input+ V2823) (and (cons? V2824) (and (= input+ (hd V2824)) (and (cons? (tl V2824)) (and (cons? (tl (tl V2824))) (= () (tl (tl (tl V2824))))))))) (cons input+ (cons (hd (tl V2824)) (cons (shen.process-applications (hd (tl (tl V2824))) V2825) ())))) ((and (cons? V2824) (shen.special? (hd V2824))) (cons (hd V2824) (map (lambda Z2827 (shen.process-applications Z2827 V2825)) (tl V2824)))) ((and (cons? V2824) (shen.extraspecial? (hd V2824))) V2824) (true (simple-error "partial function shen.special-case"))))

(defun shen.process-after-type (V2830 V2831 V2832) (cond ((and (cons? V2831) (= } (hd V2831))) (cons } (map (lambda Z2833 (shen.process-applications Z2833 V2832)) (tl V2831)))) ((cons? V2831) (cons (hd V2831) (shen.process-after-type V2830 (tl V2831) V2832))) (true (simple-error (cn "missing } in " (shen.app V2830 "
" shen.a))))))

(defun shen.process-application (V2834 V2835) (cond ((cons? V2834) (let W2836 (arity (hd V2834)) (let W2837 (length (tl V2834)) (if (element? V2834 V2835) V2834 (if (shen.shen-call? (hd V2834)) V2834 (if (shen.foreign? V2834) (shen.unpack-foreign V2834) (if (shen.fn-call? V2834) (shen.fn-call V2834) (if (shen.zero-place? V2834) V2834 (if (shen.undefined-f? (hd V2834) W2836) (shen.simple-curry (cons (cons fn (cons (hd V2834) ())) (tl V2834))) (if (variable? (hd V2834)) (shen.simple-curry V2834) (if (shen.application? (hd V2834)) (shen.simple-curry V2834) (if (shen.partial-application*? (hd V2834) W2836 W2837) (shen.lambda-function V2834 (- W2836 W2837)) (if (shen.overapplication? (hd V2834) W2836 W2837) (shen.simple-curry (cons (cons fn (cons (hd V2834) ())) (tl V2834))) V2834))))))))))))) (true (simple-error "partial function shen.process-application"))))

(defun shen.unpack-foreign (V2838) (cond ((and (cons? V2838) (and (cons? (hd V2838)) (and (= foreign (hd (hd V2838))) (and (cons? (tl (hd V2838))) (= () (tl (tl (hd V2838)))))))) (cons (hd (tl (hd V2838))) (tl V2838))) (true (simple-error "partial function shen.unpack-foreign"))))

(defun shen.foreign? (V2841) (cond ((and (cons? V2841) (and (cons? (hd V2841)) (and (= foreign (hd (hd V2841))) (and (cons? (tl (hd V2841))) (= () (tl (tl (hd V2841)))))))) true) (true false)))

(defun shen.zero-place? (V2844) (cond ((and (cons? V2844) (= () (tl V2844))) true) (true false)))

(defun shen.shen-call? (V2845) (and (symbol? V2845) (shen.internal-to-shen? (str V2845))))

(defun shen.application? (V2850) (cond ((and (cons? V2850) (and (= protect (hd V2850)) (and (cons? (tl V2850)) (= () (tl (tl V2850)))))) false) ((and (cons? V2850) (and (= foreign (hd V2850)) (and (cons? (tl V2850)) (= () (tl (tl V2850)))))) false) (true (cons? V2850))))

(defun shen.undefined-f? (V2855 V2856) (cond ((= -1 V2856) (and (shen.lowercase-symbol? V2855) (not (element? V2855 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V2857) (and (symbol? V2857) (not (variable? V2857))))

(defun shen.simple-curry (V2858) (cond ((and (cons? V2858) (and (cons? (tl V2858)) (= () (tl (tl V2858))))) V2858) ((and (cons? V2858) (and (cons? (tl V2858)) (cons? (tl (tl V2858))))) (shen.simple-curry (cons (cons (hd V2858) (cons (hd (tl V2858)) ())) (tl (tl V2858))))) (true V2858)))

(defun function (V2859) (fn V2859))

(defun fn (V2860) (cond ((= (arity V2860) 0) (V2860)) (true (let W2861 (assoc V2860 (value shen.*lambdatable*)) (if (empty? W2861) (simple-error (cn "fn: " (shen.app V2860 " is undefined
" shen.a))) (tl W2861))))))

(defun shen.fn-call? (V2864) (cond ((and (cons? V2864) (and (= fn (hd V2864)) (and (cons? (tl V2864)) (= () (tl (tl V2864)))))) true) ((and (cons? V2864) (and (= function (hd V2864)) (and (cons? (tl V2864)) (= () (tl (tl V2864)))))) true) (true false)))

(defun shen.fn-call (V2865) (cond ((and (cons? V2865) (and (= function (hd V2865)) (and (cons? (tl V2865)) (= () (tl (tl V2865)))))) (shen.fn-call (cons fn (tl V2865)))) ((and (cons? V2865) (and (= fn (hd V2865)) (and (cons? (tl V2865)) (= () (tl (tl V2865)))))) (let W2866 (arity (hd (tl V2865))) (if (= W2866 -1) V2865 (if (= W2866 0) (tl V2865) (shen.lambda-function (tl V2865) W2866))))) (true (simple-error "partial function shen.fn-call"))))

(defun shen.partial-application*? (V2867 V2868 V2869) (let W2870 (> V2868 V2869) (let W2871 (if (and W2870 (and (shen.loading?) (not (element? V2867 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V2867 "
" shen.a)) (stoutput)) shen.skip) W2870)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V2876 V2877 V2878) (cond ((= -1 V2877) false) (true (let W2879 (< V2877 V2878) (let W2880 (if (and W2879 (shen.loading?)) (pr (shen.app V2876 (cn " might not like " (shen.app V2878 (cn " argument" (shen.app (if (= V2878 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) W2879)))))

