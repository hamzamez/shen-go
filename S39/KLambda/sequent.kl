(defun shen.<datatype> (V3020) (let W3021 (if (cons? V3020) (let W3022 (head V3020) (let W3023 (tail V3020) (let W3024 (shen.<datatype-rules> W3023) (if (shen.parse-failure? W3024) (shen.parse-failure) (let W3025 (shen.<-out W3024) (let W3026 (shen.in-> W3024) (shen.comb W3026 (let W3027 (shen.rules->prolog W3022 W3025) (shen.remember-datatype W3022 (fn W3022)))))))))) (shen.parse-failure)) (if (shen.parse-failure? W3021) (shen.parse-failure) W3021)))

(defun shen.<datatype-rules> (V3028) (let W3029 (let W3030 (shen.<datatype-rule> V3028) (if (shen.parse-failure? W3030) (shen.parse-failure) (let W3031 (shen.<-out W3030) (let W3032 (shen.in-> W3030) (let W3033 (shen.<datatype-rules> W3032) (if (shen.parse-failure? W3033) (shen.parse-failure) (let W3034 (shen.<-out W3033) (let W3035 (shen.in-> W3033) (shen.comb W3035 (append W3031 W3034)))))))))) (if (shen.parse-failure? W3029) (let W3036 (let W3037 (<!> V3028) (if (shen.parse-failure? W3037) (shen.parse-failure) (let W3038 (shen.<-out W3037) (let W3039 (shen.in-> W3037) (shen.comb W3039 (if (empty? W3038) () (simple-error (cn "datatype syntax error here:
 " (shen.app W3038 "
 ..." shen.r))))))))) (if (shen.parse-failure? W3036) (shen.parse-failure) W3036)) W3029)))

(defun shen.<datatype-rule> (V3040) (let W3041 (let W3042 (shen.<single> V3040) (if (shen.parse-failure? W3042) (shen.parse-failure) (let W3043 (shen.<-out W3042) (let W3044 (shen.in-> W3042) (shen.comb W3044 W3043))))) (if (shen.parse-failure? W3041) (let W3045 (let W3046 (shen.<double> V3040) (if (shen.parse-failure? W3046) (shen.parse-failure) (let W3047 (shen.<-out W3046) (let W3048 (shen.in-> W3046) (shen.comb W3048 W3047))))) (if (shen.parse-failure? W3045) (shen.parse-failure) W3045)) W3041)))

(defun shen.<single> (V3049) (let W3050 (let W3051 (shen.<sides> V3049) (if (shen.parse-failure? W3051) (shen.parse-failure) (let W3052 (shen.<-out W3051) (let W3053 (shen.in-> W3051) (let W3054 (shen.<prems> W3053) (if (shen.parse-failure? W3054) (shen.parse-failure) (let W3055 (shen.<-out W3054) (let W3056 (shen.in-> W3054) (let W3057 (shen.<sng> W3056) (if (shen.parse-failure? W3057) (shen.parse-failure) (let W3058 (shen.in-> W3057) (let W3059 (shen.<conc> W3058) (if (shen.parse-failure? W3059) (shen.parse-failure) (let W3060 (shen.<-out W3059) (let W3061 (shen.in-> W3059) (let W3062 (shen.<sc> W3061) (if (shen.parse-failure? W3062) (shen.parse-failure) (let W3063 (shen.in-> W3062) (shen.comb W3063 (cons (cons W3052 (cons W3055 (cons W3060 ()))) ())))))))))))))))))))) (if (shen.parse-failure? W3050) (shen.parse-failure) W3050)))

(defun shen.<double> (V3064) (let W3065 (let W3066 (shen.<sides> V3064) (if (shen.parse-failure? W3066) (shen.parse-failure) (let W3067 (shen.<-out W3066) (let W3068 (shen.in-> W3066) (let W3069 (shen.<formulae> W3068) (if (shen.parse-failure? W3069) (shen.parse-failure) (let W3070 (shen.<-out W3069) (let W3071 (shen.in-> W3069) (let W3072 (shen.<dbl> W3071) (if (shen.parse-failure? W3072) (shen.parse-failure) (let W3073 (shen.in-> W3072) (let W3074 (shen.<formula> W3073) (if (shen.parse-failure? W3074) (shen.parse-failure) (let W3075 (shen.<-out W3074) (let W3076 (shen.in-> W3074) (let W3077 (shen.<sc> W3076) (if (shen.parse-failure? W3077) (shen.parse-failure) (let W3078 (shen.in-> W3077) (shen.comb W3078 (shen.lr-rule W3067 W3070 (cons () (cons W3075 ())))))))))))))))))))))) (if (shen.parse-failure? W3065) (shen.parse-failure) W3065)))

(defun shen.<formulae> (V3079) (let W3080 (let W3081 (shen.<formula> V3079) (if (shen.parse-failure? W3081) (shen.parse-failure) (let W3082 (shen.<-out W3081) (let W3083 (shen.in-> W3081) (let W3084 (shen.<sc> W3083) (if (shen.parse-failure? W3084) (shen.parse-failure) (let W3085 (shen.in-> W3084) (let W3086 (shen.<formulae> W3085) (if (shen.parse-failure? W3086) (shen.parse-failure) (let W3087 (shen.<-out W3086) (let W3088 (shen.in-> W3086) (shen.comb W3088 (cons (cons () (cons W3082 ())) W3087))))))))))))) (if (shen.parse-failure? W3080) (let W3089 (let W3090 (shen.<formula> V3079) (if (shen.parse-failure? W3090) (shen.parse-failure) (let W3091 (shen.<-out W3090) (let W3092 (shen.in-> W3090) (let W3093 (shen.<sc> W3092) (if (shen.parse-failure? W3093) (shen.parse-failure) (let W3094 (shen.in-> W3093) (shen.comb W3094 (cons (cons () (cons W3091 ())) ()))))))))) (if (shen.parse-failure? W3089) (shen.parse-failure) W3089)) W3080)))

(defun shen.<conc> (V3095) (let W3096 (let W3097 (shen.<ass> V3095) (if (shen.parse-failure? W3097) (shen.parse-failure) (let W3098 (shen.<-out W3097) (let W3099 (shen.in-> W3097) (if (shen.hds=? W3099 >>) (let W3100 (tail W3099) (let W3101 (shen.<formula> W3100) (if (shen.parse-failure? W3101) (shen.parse-failure) (let W3102 (shen.<-out W3101) (let W3103 (shen.in-> W3101) (shen.comb W3103 (cons W3098 (cons W3102 ())))))))) (shen.parse-failure)))))) (if (shen.parse-failure? W3096) (let W3104 (let W3105 (shen.<formula> V3095) (if (shen.parse-failure? W3105) (shen.parse-failure) (let W3106 (shen.<-out W3105) (let W3107 (shen.in-> W3105) (shen.comb W3107 (cons () (cons W3106 ()))))))) (if (shen.parse-failure? W3104) (shen.parse-failure) W3104)) W3096)))

(defun shen.<prems> (V3108) (let W3109 (let W3110 (shen.<prem> V3108) (if (shen.parse-failure? W3110) (shen.parse-failure) (let W3111 (shen.<-out W3110) (let W3112 (shen.in-> W3110) (let W3113 (shen.<sc> W3112) (if (shen.parse-failure? W3113) (shen.parse-failure) (let W3114 (shen.in-> W3113) (let W3115 (shen.<prems> W3114) (if (shen.parse-failure? W3115) (shen.parse-failure) (let W3116 (shen.<-out W3115) (let W3117 (shen.in-> W3115) (shen.comb W3117 (cons W3111 W3116))))))))))))) (if (shen.parse-failure? W3109) (let W3118 (let W3119 (<e> V3108) (if (shen.parse-failure? W3119) (shen.parse-failure) (let W3120 (shen.in-> W3119) (shen.comb W3120 ())))) (if (shen.parse-failure? W3118) (shen.parse-failure) W3118)) W3109)))

(defun shen.<prem> (V3121) (let W3122 (if (shen.hds=? V3121 !) (let W3123 (tail V3121) (shen.comb W3123 !)) (shen.parse-failure)) (if (shen.parse-failure? W3122) (let W3124 (let W3125 (shen.<ass> V3121) (if (shen.parse-failure? W3125) (shen.parse-failure) (let W3126 (shen.<-out W3125) (let W3127 (shen.in-> W3125) (if (shen.hds=? W3127 >>) (let W3128 (tail W3127) (let W3129 (shen.<formula> W3128) (if (shen.parse-failure? W3129) (shen.parse-failure) (let W3130 (shen.<-out W3129) (let W3131 (shen.in-> W3129) (shen.comb W3131 (cons W3126 (cons W3130 ())))))))) (shen.parse-failure)))))) (if (shen.parse-failure? W3124) (let W3132 (let W3133 (shen.<formula> V3121) (if (shen.parse-failure? W3133) (shen.parse-failure) (let W3134 (shen.<-out W3133) (let W3135 (shen.in-> W3133) (shen.comb W3135 (cons () (cons W3134 ()))))))) (if (shen.parse-failure? W3132) (shen.parse-failure) W3132)) W3124)) W3122)))

(defun shen.<ass> (V3136) (let W3137 (let W3138 (shen.<formula> V3136) (if (shen.parse-failure? W3138) (shen.parse-failure) (let W3139 (shen.<-out W3138) (let W3140 (shen.in-> W3138) (let W3141 (shen.<iscomma> W3140) (if (shen.parse-failure? W3141) (shen.parse-failure) (let W3142 (shen.in-> W3141) (let W3143 (shen.<ass> W3142) (if (shen.parse-failure? W3143) (shen.parse-failure) (let W3144 (shen.<-out W3143) (let W3145 (shen.in-> W3143) (shen.comb W3145 (cons W3139 W3144))))))))))))) (if (shen.parse-failure? W3137) (let W3146 (let W3147 (shen.<formula> V3136) (if (shen.parse-failure? W3147) (shen.parse-failure) (let W3148 (shen.<-out W3147) (let W3149 (shen.in-> W3147) (shen.comb W3149 (cons W3148 ())))))) (if (shen.parse-failure? W3146) (let W3150 (let W3151 (<e> V3136) (if (shen.parse-failure? W3151) (shen.parse-failure) (let W3152 (shen.in-> W3151) (shen.comb W3152 ())))) (if (shen.parse-failure? W3150) (shen.parse-failure) W3150)) W3146)) W3137)))

(defun shen.<iscomma> (V3153) (let W3154 (if (cons? V3153) (let W3155 (head V3153) (let W3156 (tail V3153) (if (= W3155 (intern ",")) (shen.comb W3156 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3154) (shen.parse-failure) W3154)))

(defun shen.<formula> (V3157) (let W3158 (let W3159 (shen.<expr> V3157) (if (shen.parse-failure? W3159) (shen.parse-failure) (let W3160 (shen.<-out W3159) (let W3161 (shen.in-> W3159) (let W3162 (shen.<iscolon> W3161) (if (shen.parse-failure? W3162) (shen.parse-failure) (let W3163 (shen.in-> W3162) (let W3164 (shen.<type> W3163) (if (shen.parse-failure? W3164) (shen.parse-failure) (let W3165 (shen.<-out W3164) (let W3166 (shen.in-> W3164) (shen.comb W3166 (cons (shen.curry W3160) (cons (intern ":") (cons (shen.rectify-type W3165) ()))))))))))))))) (if (shen.parse-failure? W3158) (let W3167 (let W3168 (shen.<expr> V3157) (if (shen.parse-failure? W3168) (shen.parse-failure) (let W3169 (shen.<-out W3168) (let W3170 (shen.in-> W3168) (shen.comb W3170 W3169))))) (if (shen.parse-failure? W3167) (shen.parse-failure) W3167)) W3158)))

(defun shen.<iscolon> (V3171) (let W3172 (if (cons? V3171) (let W3173 (head V3171) (let W3174 (tail V3171) (if (= W3173 (intern ":")) (shen.comb W3174 shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3172) (shen.parse-failure) W3172)))

(defun shen.<sides> (V3175) (let W3176 (let W3177 (shen.<side> V3175) (if (shen.parse-failure? W3177) (shen.parse-failure) (let W3178 (shen.<-out W3177) (let W3179 (shen.in-> W3177) (let W3180 (shen.<sides> W3179) (if (shen.parse-failure? W3180) (shen.parse-failure) (let W3181 (shen.<-out W3180) (let W3182 (shen.in-> W3180) (shen.comb W3182 (cons W3178 W3181)))))))))) (if (shen.parse-failure? W3176) (let W3183 (let W3184 (<e> V3175) (if (shen.parse-failure? W3184) (shen.parse-failure) (let W3185 (shen.in-> W3184) (shen.comb W3185 ())))) (if (shen.parse-failure? W3183) (shen.parse-failure) W3183)) W3176)))

(defun shen.<side> (V3186) (let W3187 (if (shen.hds=? V3186 if) (let W3188 (tail V3186) (if (cons? W3188) (let W3189 (head W3188) (let W3190 (tail W3188) (shen.comb W3190 (cons if (cons W3189 ()))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W3187) (let W3191 (if (shen.hds=? V3186 let) (let W3192 (tail V3186) (if (cons? W3192) (let W3193 (head W3192) (let W3194 (tail W3192) (if (cons? W3194) (let W3195 (head W3194) (let W3196 (tail W3194) (shen.comb W3196 (cons let (cons W3193 (cons W3195 ())))))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W3191) (let W3197 (if (shen.hds=? V3186 shen.let!) (let W3198 (tail V3186) (if (cons? W3198) (let W3199 (head W3198) (let W3200 (tail W3198) (if (cons? W3200) (let W3201 (head W3200) (let W3202 (tail W3200) (shen.comb W3202 (cons shen.let! (cons W3199 (cons W3201 ())))))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? W3197) (shen.parse-failure) W3197)) W3191)) W3187)))

(defun shen.lr-rule (V3209 V3210 V3211) (cond ((and (cons? V3211) (and (= () (hd V3211)) (and (cons? (tl V3211)) (= () (tl (tl V3211)))))) (let W3212 (gensym P) (let W3213 (cons (tl V3211) (cons W3212 ())) (let W3214 (cons (shen.coll-formulae V3210) (cons W3212 ())) (let W3215 (cons V3209 (cons (cons W3214 ()) (cons W3213 ()))) (let W3216 (cons V3209 (cons V3210 (cons V3211 ()))) (cons W3216 (cons W3215 ())))))))) (true (simple-error "implementation error in shen.lr-rule"))))

(defun shen.coll-formulae (V3219) (cond ((= () V3219) ()) ((and (cons? V3219) (and (cons? (hd V3219)) (and (= () (hd (hd V3219))) (and (cons? (tl (hd V3219))) (= () (tl (tl (hd V3219)))))))) (cons (hd (tl (hd V3219))) (shen.coll-formulae (tl V3219)))) (true (simple-error "implementation error in shen.coll-formulae"))))

(defun shen.<expr> (V3220) (let W3221 (if (cons? V3220) (let W3222 (head V3220) (let W3223 (tail V3220) (if (not (shen.key-in-sequent-calculus? W3222)) (shen.comb W3223 (macroexpand W3222)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3221) (shen.parse-failure) W3221)))

(defun shen.key-in-sequent-calculus? (V3224) (or (element? V3224 (cons >> (cons (intern ";") (cons (intern ",") (cons (intern ":") (cons <-- ())))))) (or (shen.sng? V3224) (shen.dbl? V3224))))

(defun shen.<type> (V3225) (let W3226 (let W3227 (shen.<expr> V3225) (if (shen.parse-failure? W3227) (shen.parse-failure) (let W3228 (shen.<-out W3227) (let W3229 (shen.in-> W3227) (shen.comb W3229 W3228))))) (if (shen.parse-failure? W3226) (shen.parse-failure) W3226)))

(defun shen.<dbl> (V3230) (let W3231 (if (cons? V3230) (let W3232 (head V3230) (let W3233 (tail V3230) (if (shen.dbl? W3232) (shen.comb W3233 W3232) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3231) (shen.parse-failure) W3231)))

(defun shen.<sng> (V3234) (let W3235 (if (cons? V3234) (let W3236 (head V3234) (let W3237 (tail V3234) (if (shen.sng? W3236) (shen.comb W3237 W3236) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? W3235) (shen.parse-failure) W3235)))

(defun shen.sng? (V3238) (and (symbol? V3238) (shen.sng-h? (str V3238))))

(defun shen.sng-h? (V3241) (cond ((= "___" V3241) true) ((and (shen.+string? V3241) (= "_" (hdstr V3241))) (shen.sng-h? (tlstr V3241))) (true false)))

(defun shen.dbl? (V3242) (and (symbol? V3242) (shen.dbl-h? (str V3242))))

(defun shen.dbl-h? (V3245) (cond ((= "===" V3245) true) ((and (shen.+string? V3245) (= "=" (hdstr V3245))) (shen.dbl-h? (tlstr V3245))) (true false)))

(defun shen.remember-datatype (V3246 V3247) (do (set shen.*datatypes* (shen.assoc-> V3246 V3247 (value shen.*datatypes*))) (do (set shen.*alldatatypes* (shen.assoc-> V3246 V3247 (value shen.*alldatatypes*))) V3246)))

(defun shen.rules->prolog (V3248 V3249) (let W3250 (mapcan (lambda Z3251 (shen.rule->clause Z3251)) V3249) (eval (cons defprolog (cons V3248 W3250)))))

(defun shen.rule->clause (V3254) (cond ((and (cons? V3254) (and (cons? (tl V3254)) (and (cons? (tl (tl V3254))) (and (cons? (hd (tl (tl V3254)))) (and (cons? (tl (hd (tl (tl V3254))))) (and (= () (tl (tl (hd (tl (tl V3254)))))) (= () (tl (tl (tl V3254)))))))))) (let W3255 (shen.extract-vars V3254) (let W3256 (append (shen.nvars (length (hd (hd (tl (tl V3254)))))) (cons Delta ())) (let W3257 (shen.extract-vars (hd (tl (hd (tl (tl V3254)))))) (let W3258 (shen.compile-consequent (hd (tl (hd (tl (tl V3254))))) W3256) (let W3259 (shen.goals W3255 (hd (hd (tl (tl V3254)))) (hd V3254) (hd (tl V3254)) W3256 W3257) (append W3258 (append (cons <-- ()) (append W3259 (cons (intern ";") ())))))))))) (true (simple-error "implementation error in shen.rule->clause"))))

(defun shen.compile-consequent (V3266 V3267) (cond ((cons? V3267) (cons (shen.optimise-typing V3266) (cons (hd V3267) ()))) (true (simple-error "implementation error in shen.compile-consequent"))))

(defun shen.nvars (V3268) (cond ((= 0 V3268) ()) (true (cons (gensym V) (shen.nvars (- V3268 1))))))

(defun shen.optimise-typing (V3269) (cond ((and (cons? V3269) (and (cons? (tl V3269)) (and (cons? (tl (tl V3269))) (and (= () (tl (tl (tl V3269)))) (= (hd (tl V3269)) (intern ":")))))) (let W3270 (shen.expand-mode-forms (cons - (cons (cons (hd V3269) (cons (hd (tl V3269)) (cons (cons + (tl (tl V3269))) ()))) ()))) (shen.cons-form-with-modes W3270))) (true (let W3271 (shen.expand-mode-forms (cons + (cons V3269 ()))) (shen.cons-form-with-modes W3271)))))

(defun shen.expand-mode-forms (V3272) (cond ((and (cons? V3272) (and (= + (hd V3272)) (and (cons? (tl V3272)) (= () (tl (tl V3272)))))) (cons mode (cons (shen.expand-mode-forms (hd (tl V3272))) (cons + ())))) ((and (cons? V3272) (and (= - (hd V3272)) (and (cons? (tl V3272)) (= () (tl (tl V3272)))))) (cons mode (cons (shen.expand-mode-forms (hd (tl V3272))) (cons - ())))) ((cons? V3272) (map (lambda Z3273 (shen.expand-mode-forms Z3273)) V3272)) (true V3272)))

(defun shen.cons-form-with-modes (V3274) (cond ((and (cons? V3274) (and (= mode (hd V3274)) (and (cons? (tl V3274)) (and (cons? (tl (tl V3274))) (= () (tl (tl (tl V3274)))))))) (cons (hd (tl (tl V3274))) (cons (shen.cons-form-with-modes (hd (tl V3274))) ()))) ((and (cons? V3274) (and (= bar! (hd V3274)) (and (cons? (tl V3274)) (= () (tl (tl V3274)))))) (hd (tl V3274))) ((cons? V3274) (cons cons (cons (shen.cons-form-with-modes (hd V3274)) (cons (shen.cons-form-with-modes (tl V3274)) ())))) (true V3274)))

(defun shen.goals (V3275 V3276 V3277 V3278 V3279 V3280) (let W3281 (shen.compile-assumptions V3276 V3275 V3279 V3280) (let W3282 (shen.compile-side-conditions V3277) (let W3283 (shen.compile-premises V3278 V3279) (append W3281 (append W3282 W3283))))))

(defun shen.compile-assumptions (V3298 V3299 V3300 V3301) (cond ((= () V3298) ()) ((and (cons? V3298) (and (cons? V3300) (cons? (tl V3300)))) (let W3302 (append (shen.extract-vars (hd V3298)) V3301) (cons (shen.compile-assumption (hd V3298) (hd V3300) (hd (tl V3300)) V3299 V3301) (shen.compile-assumptions (tl V3298) V3299 (tl V3300) W3302)))) (true (simple-error "implementation error in shen.compile-assumptions"))))

(defun shen.compile-assumption (V3303 V3304 V3305 V3306 V3307) (let W3308 (gensym shen.search) (let W3309 (shen.compile-search-procedure W3308 V3303 V3304 V3305 V3306 V3307) (cons W3308 (cons V3304 (cons () (cons V3305 V3306)))))))

(defun shen.compile-search-procedure (V3310 V3311 V3312 V3313 V3314 V3315) (let W3316 (gensym Previous) (let W3317 (shen.foundit! V3311 V3312 W3316 V3313 V3314 V3315) (let W3318 (shen.keep-looking V3310 V3312 W3316 V3313 V3314) (eval (cons defprolog (cons V3310 (append W3317 W3318))))))))

(defun shen.foundit! (V3319 V3320 V3321 V3322 V3323 V3324) (let W3325 (shen.passive V3319 V3324) (let W3326 (shen.tabulate-passive W3325) (let W3327 (shen.head-foundit! V3319 V3320 V3321 V3322 V3323 W3326) (let W3328 (shen.body-foundit! V3320 V3321 V3322 W3326) (append W3327 (append (cons <-- ()) (append W3328 (cons (intern ";") ())))))))))

(defun shen.keep-looking (V3329 V3330 V3331 V3332 V3333) (let W3334 (gensym V) (let W3335 (cons (cons - (cons (cons cons (cons W3334 (cons V3330 ()))) ())) (cons V3331 (cons V3332 V3333))) (let W3336 (cons (cons V3329 (cons V3330 (cons (cons cons (cons W3334 (cons V3331 ()))) (cons V3332 V3333)))) ()) (append W3335 (append (cons <-- ()) (append W3336 (cons (intern ";") ()))))))))

(defun shen.passive (V3341 V3342) (cond ((cons? V3341) (union (shen.passive (hd V3341) V3342) (shen.passive (tl V3341) V3342))) ((shen.passive? V3341 V3342) (cons V3341 ())) (true ())))

(defun shen.passive? (V3343 V3344) (and (not (element? V3343 V3344)) (variable? V3343)))

(defun shen.tabulate-passive (V3345) (map (lambda Z3346 (cons Z3346 (gensym V))) V3345))

(defun shen.head-foundit! (V3347 V3348 V3349 V3350 V3351 V3352) (let W3353 (shen.optimise-passive V3351 V3352) (cons (cons - (cons (cons cons (cons (shen.optimise-typing V3347) (cons V3348 ()))) ())) (cons V3349 (cons V3350 W3353)))))

(defun shen.optimise-passive (V3354 V3355) (map (lambda Z3356 (shen.optimise-passive-h Z3356 V3355)) V3354))

(defun shen.optimise-passive-h (V3357 V3358) (let W3359 (assoc V3357 V3358) (if (empty? W3359) V3357 (tl W3359))))

(defun shen.body-foundit! (V3368 V3369 V3370 V3371) (cond ((= () V3371) (cons (cons bind (cons V3370 (cons (cons append (cons (cons 1 (cons V3369 ())) (cons (cons 1 (cons V3368 ())) ()))) ()))) ())) ((and (cons? V3371) (cons? (hd V3371))) (cons (cons bind (cons (tl (hd V3371)) (cons (hd (hd V3371)) ()))) (shen.body-foundit! V3368 V3369 V3370 (tl V3371)))) (true (simple-error "implementation error in shen.body-foundit!"))))

(defun shen.compile-side-conditions (V3372) (map (lambda Z3373 (shen.compile-side-condition Z3373)) V3372))

(defun shen.compile-side-condition (V3376) (cond ((and (cons? V3376) (and (= let (hd V3376)) (and (cons? (tl V3376)) (and (cons? (tl (tl V3376))) (= () (tl (tl (tl V3376)))))))) (cons is (tl V3376))) ((and (cons? V3376) (and (= shen.let! (hd V3376)) (and (cons? (tl V3376)) (and (cons? (tl (tl V3376))) (= () (tl (tl (tl V3376)))))))) (cons is! (tl V3376))) ((and (cons? V3376) (and (= if (hd V3376)) (and (cons? (tl V3376)) (= () (tl (tl V3376)))))) (cons when (tl V3376))) (true (simple-error "implementation error in shen.compile-side-condition"))))

(defun shen.compile-premises (V3377 V3378) (let W3379 (hd (reverse V3378)) (map (lambda Z3380 (shen.compile-premise Z3380 W3379)) V3377)))

(defun shen.compile-premise (V3387 V3388) (cond ((= ! V3387) !) ((and (cons? V3387) (and (cons? (tl V3387)) (= () (tl (tl V3387))))) (shen.compile-premise-h (reverse (hd V3387)) (hd (tl V3387)) V3388)) (true (simple-error "implementation error in shen.premise"))))

(defun shen.compile-premise-h (V3395 V3396 V3397) (cond ((= () V3395) (cons shen.system-S (cons (shen.cons-form-no-modes V3396) (cons V3397 ())))) ((cons? V3395) (shen.compile-premise-h (tl V3395) V3396 (cons cons (cons (shen.cons-form-no-modes (hd V3395)) (cons V3397 ()))))) (true (simple-error "implementation error in shen.compile-premise-h"))))

(defun shen.cons-form-no-modes (V3398) (cond ((and (cons? V3398) (and (= bar! (hd V3398)) (and (cons? (tl V3398)) (= () (tl (tl V3398)))))) (hd (tl V3398))) ((cons? V3398) (cons cons (cons (shen.cons-form-no-modes (hd V3398)) (cons (shen.cons-form-no-modes (tl V3398)) ())))) (true V3398)))

(defun preclude (V3399) (let W3400 (map (lambda Z3401 (shen.intern-type Z3401)) V3399) (let W3402 (value shen.*datatypes*) (let W3403 (shen.remove-datatypes W3400 W3402) (let W3404 (set shen.*datatypes* W3403) (shen.show-datatypes W3404))))))

(defun shen.remove-datatypes (V3409 V3410) (cond ((= () V3409) V3410) ((cons? V3409) (shen.remove-datatypes (tl V3409) (shen.unassoc (hd V3409) V3410))) (true (simple-error "implementation error in shen.remove-datatypes"))))

(defun shen.show-datatypes (V3411) (map (lambda Z3412 (hd Z3412)) V3411))

(defun include (V3413) (let W3414 (map (lambda Z3415 (shen.intern-type Z3415)) V3413) (let W3416 (map (lambda Z3417 (shen.remember-datatype Z3417 (fn Z3417))) W3414) (let W3418 (value shen.*datatypes*) (shen.show-datatypes W3418)))))

(defun preclude-all-but (V3419) (let W3420 (set shen.*datatypes* ()) (let W3421 (map (lambda Z3422 (shen.intern-type Z3422)) V3419) (let W3423 (map (lambda Z3424 (shen.remember-datatype Z3424 (fn Z3424))) W3421) (shen.show-datatypes (value shen.*datatypes*))))))

(defun include-all-but (V3425) (let W3426 (map (lambda Z3427 (shen.intern-type Z3427)) V3425) (let W3428 (value shen.*alldatatypes*) (let W3429 (set shen.*datatypes* (shen.remove-datatypes W3426 W3428)) (shen.show-datatypes W3429)))))

