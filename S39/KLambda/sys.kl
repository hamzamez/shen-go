(defun thaw (V3487) (V3487))

(defun eval (V3488) (eval-kl (shen.shen->kl (shen.process-applications (macroexpand V3488) (shen.find-types V3488)))))

(defun external (V3489) (cond ((= null V3489) ()) (true (trap-error (get V3489 shen.external-symbols (value *property-vector*)) (lambda Z3490 (simple-error (cn "package " (shen.app V3489 " does not exist.
;" shen.a))))))))

(defun internal (V3491) (cond ((= null V3491) ()) (true (trap-error (get V3491 shen.internal-symbols (value *property-vector*)) (lambda Z3492 (simple-error (cn "package " (shen.app V3491 " does not exist.
;" shen.a))))))))

(defun fail-if (V3493 V3494) (if (V3493 V3494) (fail) V3494))

(defun @s (V3495 V3496) (cn V3495 V3496))

(defun tc? () (value shen.*tc*))

(defun occurs? () (value shen.*occurs*))

(defun factorise? () (value shen.*factorise?*))

(defun tracked () (value shen.*tracking*))

(defun ps (V3497) (trap-error (get V3497 shen.source (value *property-vector*)) (lambda Z3498 (simple-error (shen.app V3497 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun vector (V3499) (let W3500 (absvector (+ V3499 1)) (let W3501 (address-> W3500 0 V3499) (let W3502 (if (= V3499 0) W3501 (shen.fillvector W3501 1 V3499 (fail))) W3502))))

(defun shen.fillvector (V3504 V3505 V3506 V3507) (cond ((= V3505 V3506) (address-> V3504 V3506 V3507)) (true (shen.fillvector (address-> V3504 V3505 V3507) (+ 1 V3505) V3506 V3507))))

(defun vector? (V3508) (and (absvector? V3508) (trap-error (>= (<-address V3508 0) 0) (lambda Z3509 false))))

(defun vector-> (V3510 V3511 V3512) (if (= V3511 0) (simple-error "cannot access 0th element of a vector
") (address-> V3510 V3511 V3512)))

(defun <-vector (V3513 V3514) (if (= V3514 0) (simple-error "cannot access 0th element of a vector
") (let W3515 (<-address V3513 V3514) (if (= W3515 (fail)) (simple-error "vector element not found
") W3515))))

(defun shen.posint? (V3516) (and (integer? V3516) (>= V3516 0)))

(defun limit (V3517) (<-address V3517 0))

(defun symbol? (V3518) (cond ((or (boolean? V3518) (or (number? V3518) (or (string? V3518) (or (cons? V3518) (or (empty? V3518) (vector? V3518)))))) false) ((element? V3518 (cons { (cons } (cons (intern ":") (cons (intern ";") (cons (intern ",") ())))))) true) (true (trap-error (let W3519 (str V3518) (shen.analyse-symbol? W3519)) (lambda Z3520 false)))))

(defun shen.analyse-symbol? (V3523) (cond ((shen.+string? V3523) (and (shen.alpha? (string->n (hdstr V3523))) (shen.alphanums? (tlstr V3523)))) (true (simple-error "implementation error in shen.analyse-symbol?"))))

(defun shen.alphanums? (V3526) (cond ((= "" V3526) true) ((shen.+string? V3526) (let W3527 (string->n (hdstr V3526)) (and (or (shen.alpha? W3527) (shen.digit? W3527)) (shen.alphanums? (tlstr V3526))))) (true (simple-error "implementation error in shen.alphanums?"))))

(defun variable? (V3528) (cond ((or (boolean? V3528) (or (number? V3528) (string? V3528))) false) (true (trap-error (let W3529 (str V3528) (shen.analyse-variable? W3529)) (lambda Z3530 false)))))

(defun shen.analyse-variable? (V3533) (cond ((shen.+string? V3533) (and (shen.uppercase? (string->n (hdstr V3533))) (shen.alphanums? (tlstr V3533)))) (true (simple-error "implementation error in shen.analyse-variable?"))))

(defun gensym (V3534) (concat V3534 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V3535 V3536) (intern (cn (str V3535) (str V3536))))

(defun @p (V3537 V3538) (let W3539 (absvector 3) (let W3540 (address-> W3539 0 shen.tuple) (let W3541 (address-> W3539 1 V3537) (let W3542 (address-> W3539 2 V3538) W3539)))))

(defun fst (V3543) (<-address V3543 1))

(defun snd (V3544) (<-address V3544 2))

(defun tuple? (V3545) (trap-error (and (absvector? V3545) (= shen.tuple (<-address V3545 0))) (lambda Z3546 false)))

(defun append (V3551 V3552) (cond ((= () V3551) V3552) ((cons? V3551) (cons (hd V3551) (append (tl V3551) V3552))) (true (simple-error "attempt to append a non-list"))))

(defun @v (V3553 V3554) (let W3555 (limit V3554) (let W3556 (vector (+ W3555 1)) (let W3557 (vector-> W3556 1 V3553) (if (= W3555 0) W3557 (shen.@v-help V3554 1 W3555 W3557))))))

(defun shen.@v-help (V3559 V3560 V3561 V3562) (cond ((= V3560 V3561) (shen.copyfromvector V3559 V3562 V3561 (+ V3561 1))) (true (shen.@v-help V3559 (+ V3560 1) V3561 (shen.copyfromvector V3559 V3562 V3560 (+ V3560 1))))))

(defun shen.copyfromvector (V3563 V3564 V3565 V3566) (trap-error (vector-> V3564 V3566 (<-vector V3563 V3565)) (lambda Z3567 V3564)))

(defun hdv (V3568) (trap-error (<-vector V3568 1) (lambda Z3569 (simple-error "hdv needs a non-empty vector as an argument
"))))

(defun tlv (V3570) (let W3571 (limit V3570) (if (= W3571 0) (simple-error "cannot take the tail of the empty vector
") (if (= W3571 1) (vector 0) (let W3572 (vector (- W3571 1)) (shen.tlv-help V3570 2 W3571 (vector (- W3571 1))))))))

(defun shen.tlv-help (V3574 V3575 V3576 V3577) (cond ((= V3575 V3576) (shen.copyfromvector V3574 V3577 V3576 (- V3576 1))) (true (shen.tlv-help V3574 (+ V3575 1) V3576 (shen.copyfromvector V3574 V3577 V3575 (- V3575 1))))))

(defun assoc (V3589 V3590) (cond ((= () V3590) ()) ((and (cons? V3590) (and (cons? (hd V3590)) (= V3589 (hd (hd V3590))))) (hd V3590)) ((cons? V3590) (assoc V3589 (tl V3590))) (true (simple-error "attempt to search a non-list with assoc
"))))

(defun boolean? (V3593) (cond ((= true V3593) true) ((= false V3593) true) (true false)))

(defun nl (V3594) (cond ((= 0 V3594) 0) (true (do (pr "
" (stoutput)) (nl (- V3594 1))))))

(defun difference (V3601 V3602) (cond ((= () V3601) ()) ((cons? V3601) (if (element? (hd V3601) V3602) (difference (tl V3601) V3602) (cons (hd V3601) (difference (tl V3601) V3602)))) (true (simple-error "attempt to find the difference with a non-list
"))))

(defun do (V3603 V3604) V3604)

(defun element? (V3616 V3617) (cond ((= () V3617) false) ((and (cons? V3617) (= V3616 (hd V3617))) true) ((cons? V3617) (element? V3616 (tl V3617))) (true (simple-error "attempt to find an element in a non-list
"))))

(defun empty? (V3620) (cond ((= () V3620) true) (true false)))

(defun fix (V3621 V3622) (shen.fix-help V3621 V3622 (V3621 V3622)))

(defun shen.fix-help (V3628 V3629 V3630) (cond ((= V3629 V3630) V3630) (true (shen.fix-help V3628 V3630 (V3628 V3630)))))

(defun put (V3631 V3632 V3633 V3634) (let W3635 (hash V3631 (limit V3634)) (let W3636 (trap-error (<-vector V3634 W3635) (lambda Z3637 ())) (let W3638 (vector-> V3634 W3635 (shen.change-pointer-value V3631 V3632 V3633 W3636)) V3633))))

(defun unput (V3639 V3640 V3641) (let W3642 (hash V3639 (limit V3641)) (let W3643 (trap-error (<-vector V3641 W3642) (lambda Z3644 ())) (let W3645 (vector-> V3641 W3642 (shen.remove-pointer V3639 V3640 W3643)) V3639))))

(defun shen.remove-pointer (V3656 V3657 V3658) (cond ((= () V3658) ()) ((and (cons? V3658) (and (cons? (hd V3658)) (and (cons? (hd (hd V3658))) (and (cons? (tl (hd (hd V3658)))) (and (= () (tl (tl (hd (hd V3658))))) (and (= V3657 (hd (tl (hd (hd V3658))))) (= V3656 (hd (hd (hd V3658)))))))))) (tl V3658)) ((cons? V3658) (cons (hd V3658) (shen.remove-pointer V3656 V3657 (tl V3658)))) (true (simple-error "implementation error in shen.remove-pointer"))))

(defun shen.change-pointer-value (V3671 V3672 V3673 V3674) (cond ((= () V3674) (cons (cons (cons V3671 (cons V3672 ())) V3673) ())) ((and (cons? V3674) (and (cons? (hd V3674)) (and (cons? (hd (hd V3674))) (and (cons? (tl (hd (hd V3674)))) (and (= () (tl (tl (hd (hd V3674))))) (and (= V3672 (hd (tl (hd (hd V3674))))) (= V3671 (hd (hd (hd V3674)))))))))) (cons (cons (hd (hd V3674)) V3673) (tl V3674))) ((cons? V3674) (cons (hd V3674) (shen.change-pointer-value V3671 V3672 V3673 (tl V3674)))) (true (simple-error "implementation error in shen.change-pointer-value"))))

(defun get (V3675 V3676 V3677) (let W3678 (hash V3675 (limit V3677)) (let W3679 (trap-error (<-vector V3677 W3678) (lambda Z3680 (simple-error (shen.app V3675 (cn " has no attributes: " (shen.app V3676 "
" shen.s)) shen.a)))) (let W3681 (assoc (cons V3675 (cons V3676 ())) W3679) (if (empty? W3681) (simple-error (cn "attribute " (shen.app V3676 (cn " not found for " (shen.app V3675 "
" shen.s)) shen.s))) (tl W3681))))))

(defun hash (V3682 V3683) (let W3684 (shen.mod (shen.hashkey V3682) V3683) (if (= W3684 0) 1 W3684)))

(defun shen.hashkey (V3685) (let W3686 (map (lambda Z3687 (string->n Z3687)) (explode V3685)) (shen.prodbutzero W3686 1)))

(defun shen.prodbutzero (V3688 V3689) (cond ((= () V3688) V3689) ((and (cons? V3688) (= 0 (hd V3688))) (shen.prodbutzero (tl V3688) V3689)) ((cons? V3688) (if (> V3689 10000000000) (shen.prodbutzero (tl V3688) (+ V3689 (hd V3688))) (shen.prodbutzero (tl V3688) (* V3689 (hd V3688))))) (true (simple-error "partial function shen.prodbutzero"))))

(defun shen.mod (V3690 V3691) (shen.modh V3690 (shen.multiples V3690 (cons V3691 ()))))

(defun shen.multiples (V3696 V3697) (cond ((and (cons? V3697) (> (hd V3697) V3696)) (tl V3697)) ((cons? V3697) (shen.multiples V3696 (cons (* 2 (hd V3697)) V3697))) (true (simple-error "implementation error in shen.multiples"))))

(defun shen.modh (V3704 V3705) (cond ((= 0 V3704) 0) ((= () V3705) V3704) ((and (cons? V3705) (> (hd V3705) V3704)) (if (empty? (tl V3705)) V3704 (shen.modh V3704 (tl V3705)))) ((cons? V3705) (shen.modh (- V3704 (hd V3705)) V3705)) (true (simple-error "implementation error in shen.modh"))))

(defun sum (V3708) (cond ((= () V3708) 0) ((cons? V3708) (+ (hd V3708) (sum (tl V3708)))) (true (simple-error "attempt to sum a non-list
"))))

(defun head (V3713) (cond ((cons? V3713) (hd V3713)) (true (simple-error "head expects a non-empty list
"))))

(defun tail (V3718) (cond ((cons? V3718) (tl V3718)) (true (simple-error "tail expects a non-empty list
"))))

(defun hdstr (V3719) (pos V3719 0))

(defun intersection (V3726 V3727) (cond ((= () V3726) ()) ((cons? V3726) (if (element? (hd V3726) V3727) (cons (hd V3726) (intersection (tl V3726) V3727)) (intersection (tl V3726) V3727))) (true (simple-error "attempt to find the intersection with a non-list
"))))

(defun reverse (V3728) (shen.reverse-help V3728 ()))

(defun shen.reverse-help (V3733 V3734) (cond ((= () V3733) V3734) ((cons? V3733) (shen.reverse-help (tl V3733) (cons (hd V3733) V3734))) (true (simple-error "attempt to reverse a non-list
"))))

(defun union (V3739 V3740) (cond ((= () V3739) V3740) ((cons? V3739) (if (element? (hd V3739) V3740) (union (tl V3739) V3740) (cons (hd V3739) (union (tl V3739) V3740)))) (true (simple-error "attempt to find the union with a non-list
"))))

(defun y-or-n? (V3741) (let W3742 (pr (shen.proc-nl V3741) (stoutput)) (let W3743 (pr " (y/n) " (stoutput)) (let W3744 (shen.app (read (stinput)) "" shen.s) (if (= "y" W3744) true (if (= "n" W3744) false (do (pr "please answer y or n
" (stoutput)) (y-or-n? V3741))))))))

(defun not (V3745) (if V3745 false true))

(defun abort () (simple-error ""))

(defun subst (V3751 V3752 V3753) (cond ((= V3752 V3753) V3751) ((cons? V3753) (cons (subst V3751 V3752 (hd V3753)) (subst V3751 V3752 (tl V3753)))) (true V3753)))

(defun explode (V3754) (shen.explode-h (shen.app V3754 "" shen.a)))

(defun shen.explode-h (V3757) (cond ((= "" V3757) ()) ((shen.+string? V3757) (cons (hdstr V3757) (shen.explode-h (tlstr V3757)))) (true (simple-error "implementation error in explode-h"))))

(defun cd (V3758) (set *home-directory* (if (= V3758 "") "" (shen.app V3758 "/" shen.a))))

(defun map (V3759 V3760) (shen.map-h V3759 V3760 ()))

(defun shen.map-h (V3761 V3762 V3763) (cond ((= () V3762) (reverse V3763)) ((cons? V3762) (shen.map-h V3761 (tl V3762) (cons (V3761 (hd V3762)) V3763))) (true (simple-error "partial function shen.map-h"))))

(defun length (V3764) (shen.length-h V3764 0))

(defun shen.length-h (V3769 V3770) (cond ((= () V3769) V3770) (true (shen.length-h (tl V3769) (+ V3770 1)))))

(defun occurrences (V3776 V3777) (cond ((= V3776 V3777) 1) ((cons? V3777) (+ (occurrences V3776 (hd V3777)) (occurrences V3776 (tl V3777)))) (true 0)))

(defun nth (V3782 V3783) (cond ((and (= 1 V3782) (cons? V3783)) (hd V3783)) ((cons? V3783) (nth (- V3782 1) (tl V3783))) (true (simple-error (cn "nth applied to " (shen.app V3782 (cn ", " (shen.app V3783 "
" shen.a)) shen.a))))))

(defun integer? (V3784) (and (number? V3784) (let W3785 (shen.abs V3784) (shen.integer-test? W3785 (shen.magless W3785 1)))))

(defun shen.abs (V3786) (if (> V3786 0) V3786 (- 0 V3786)))

(defun shen.magless (V3787 V3788) (let W3789 (* V3788 2) (if (> W3789 V3787) V3788 (shen.magless V3787 W3789))))

(defun shen.integer-test? (V3793 V3794) (cond ((= 0 V3793) true) ((> 1 V3793) false) (true (let W3795 (- V3793 V3794) (if (> 0 W3795) (integer? V3793) (shen.integer-test? W3795 V3794))))))

(defun mapcan (V3802 V3803) (cond ((= () V3803) ()) ((cons? V3803) (append (V3802 (hd V3803)) (mapcan V3802 (tl V3803)))) (true (simple-error "attempt to mapcan over a non-list
"))))

(defun == (V3809 V3810) (cond ((= V3809 V3810) true) (true false)))

(defun bound? (V3811) (and (symbol? V3811) (let W3812 (trap-error (value V3811) (lambda Z3813 shen.this-symbol-is-unbound)) (if (= W3812 shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V3814) (cond ((= "" V3814) ()) (true (cons (string->n (pos V3814 0)) (shen.string->bytes (tlstr V3814))))))

(defun maxinferences (V3815) (if (< V3815 0) (value shen.*maxinferences*) (if (integer? V3815) (set shen.*maxinferences* V3815) (simple-error "maxinferences expects an integer value
"))))

(defun inferences () (value shen.*infs*))

(defun protect (V3816) V3816)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V3817) (let W3818 (intern V3817) (if (symbol? W3818) W3818 (simple-error (cn "cannot intern " (shen.app V3817 " to a symbol" shen.s))))))

(defun optimise (V3821) (cond ((= + V3821) (set shen.*optimise* true)) ((= - V3821) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V3822) (cond ((= null V3822) true) (true (trap-error (do (external V3822) true) (lambda Z3823 false)))))

(defun fail () shen.fail!)(defun userdefs () (value shen.*userdefs*))

(defun optimise? () (value shen.*optimise*))

(defun hush? () (value *hush*))

(defun system-S? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3826) (cond ((= + V3826) (set shen.*shen-type-theory-enabled?* true)) ((= - V3826) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.hush (V3829) (cond ((= + V3829) (set *hush* true)) ((= - V3829) (set *hush* false)) (true (simple-error "hush expects a + or a -
"))))

(defun tc (V3832) (cond ((= + V3832) (set shen.*tc* true)) ((= - V3832) (set shen.*tc* false)) (true (simple-error "tc expects a + or -"))))

(defun destroy (V3833) (do (set shen.*sigf* (shen.unassoc V3833 (value shen.*sigf*))) V3833))

(defun shen.unassoc (V3843 V3844) (cond ((= () V3844) ()) ((and (cons? V3844) (and (cons? (hd V3844)) (= V3843 (hd (hd V3844))))) (tl V3844)) ((cons? V3844) (cons (hd V3844) (shen.unassoc V3843 (tl V3844)))) (true (simple-error "implementation error in shen.unassoc"))))

(defun in-package (V3845) (if (package? V3845) (set shen.*package* V3845) (simple-error (cn "package " (shen.app V3845 " does not exist
" shen.a)))))

(defun write-to-file (V3846 V3847) (let W3848 (open V3846 out) (let W3849 (if (string? V3847) V3847 (shen.app V3847 "" shen.s)) (let W3850 (pr W3849 W3848) (let W3851 (close W3848) V3847)))))

(defun fresh () (shen.freshterm (gensym shen.t)))

(defun update-lambda-table (V3852 V3853) (let W3854 (put V3852 arity V3853 (value *property-vector*)) (let W3855 (shen.lambda-entry V3852) (let W3856 (set shen.*lambdatable* (cons W3855 (value shen.*lambdatable*))) V3852))))

(defun specialise (V3859 V3860) (cond ((= 0 V3860) (do (set shen.*special* (remove V3859 (value shen.*special*))) (do (set shen.*extraspecial* (remove V3859 (value shen.*extraspecial*))) V3859))) ((= 1 V3860) (do (set shen.*special* (adjoin V3859 (value shen.*special*))) (do (set shen.*extraspecial* (remove V3859 (value shen.*extraspecial*))) V3859))) ((= 2 V3860) (do (set shen.*special* (remove V3859 (value shen.*special*))) (do (set shen.*extraspecial* (adjoin V3859 (value shen.*extraspecial*))) V3859))) (true (simple-error "specialise requires values of 0, 1 or 2
"))))

