"Copyright (c) 2019 Bruno Deferrari.
BSD 3-Clause License: http://opensource.org/licenses/BSD-3-Clause"

(defun shen.x.expand-dynamic.initialise () (do (set shen.x.expand-dynamic.*external-symbols* ()) (set shen.x.expand-dynamic.*arities* ())))

(defun shen.x.expand-dynamic.expand-dynamic (V5029) (cond ((= () V5029) ()) ((and (cons? V5029) (and (cons? (hd V5029)) (and (= declare (hd (hd V5029))) (and (cons? (tl (hd V5029))) (and (cons? (tl (tl (hd V5029)))) (= () (tl (tl (tl (hd V5029)))))))))) (append (shen.x.expand-dynamic.expand-declare (hd V5029)) (shen.x.expand-dynamic.expand-dynamic (tl V5029)))) ((and (cons? V5029) (and (cons? (hd V5029)) (and (= put (hd (hd V5029))) (and (cons? (tl (hd V5029))) (and (cons? (hd (tl (hd V5029)))) (and (= intern (hd (hd (tl (hd V5029))))) (and (cons? (tl (hd (tl (hd V5029))))) (and (= "shen" (hd (tl (hd (tl (hd V5029)))))) (and (= () (tl (tl (hd (tl (hd V5029)))))) (and (cons? (tl (tl (hd V5029)))) (and (= shen.external-symbols (hd (tl (tl (hd V5029))))) (and (cons? (tl (tl (tl (hd V5029))))) (and (cons? (tl (tl (tl (tl (hd V5029)))))) (= () (tl (tl (tl (tl (tl (hd V5029)))))))))))))))))))) (do (set shen.x.expand-dynamic.*external-symbols* (eval-kl (hd (tl (tl (tl (hd V5029))))))) (cons (hd V5029) (shen.x.expand-dynamic.expand-dynamic (tl V5029))))) ((and (cons? V5029) (and (cons? (hd V5029)) (and (= shen.initialise_arity_table (hd (hd V5029))) (and (cons? (tl (hd V5029))) (= () (tl (tl (hd V5029)))))))) (do (set shen.x.expand-dynamic.*arities* (eval-kl (hd (tl (hd V5029))))) (cons (hd V5029) (shen.x.expand-dynamic.expand-dynamic (tl V5029))))) ((and (cons? V5029) (and (cons? (hd V5029)) (and (= shen.for-each (hd (hd V5029))) (and (cons? (tl (hd V5029))) (and (cons? (hd (tl (hd V5029)))) (and (= lambda (hd (hd (tl (hd V5029))))) (and (cons? (tl (hd (tl (hd V5029))))) (and (cons? (tl (tl (hd (tl (hd V5029)))))) (and (cons? (hd (tl (tl (hd (tl (hd V5029))))))) (and (= shen.set-lambda-form-entry (hd (hd (tl (tl (hd (tl (hd V5029)))))))) (and (cons? (tl (hd (tl (tl (hd (tl (hd V5029)))))))) (and (= () (tl (tl (hd (tl (tl (hd (tl (hd V5029))))))))) (and (= () (tl (tl (tl (hd (tl (hd V5029))))))) (and (cons? (tl (tl (hd V5029)))) (and (= () (tl (tl (tl (hd V5029))))) (= (hd (tl (hd (tl (tl (hd (tl (hd V5029)))))))) (hd (tl (hd (tl (hd V5029))))))))))))))))))))) (append (shen.x.expand-dynamic.expand-lambda-entries (hd (tl (tl (hd V5029))))) (shen.x.expand-dynamic.expand-dynamic (tl V5029)))) ((cons? V5029) (cons (hd V5029) (shen.x.expand-dynamic.expand-dynamic (tl V5029)))) (true (shen.f_error shen.x.expand-dynamic.expand-dynamic))))

(defun shen.x.expand-dynamic.expand-declare (V5031) (cond ((and (cons? V5031) (and (= declare (hd V5031)) (and (cons? (tl V5031)) (and (cons? (tl (tl V5031))) (= () (tl (tl (tl V5031)))))))) (let Eval (eval-kl V5031) (let F* (concat shen.type-signature-of- (hd (tl V5031))) (let KlDef (ps F*) (let RecordSig (cons set (cons shen.*signedfuncs* (cons (cons cons (cons (cons cons (tl V5031)) (cons (cons value (cons shen.*signedfuncs* ())) ()))) ()))) (let RecordLambda (cons shen.set-lambda-form-entry (cons (cons cons (cons F* (cons (shen.lambda-form F* 3) ()))) ())) (cons KlDef (cons RecordSig (cons RecordLambda ()))))))))) (true (shen.f_error shen.x.expand-dynamic.expand-declare))))

(defun shen.x.expand-dynamic.expand-lambda-entries (V5034) (cond ((= () V5034) ()) ((and (cons? V5034) (and (= mapcan (hd V5034)) (and (cons? (tl V5034)) (and (cons? (hd (tl V5034))) (and (= lambda (hd (hd (tl V5034)))) (and (cons? (tl (hd (tl V5034)))) (and (cons? (tl (tl (hd (tl V5034))))) (and (cons? (hd (tl (tl (hd (tl V5034)))))) (and (= shen.lambda-form-entry (hd (hd (tl (tl (hd (tl V5034))))))) (and (cons? (tl (hd (tl (tl (hd (tl V5034))))))) (and (= () (tl (tl (hd (tl (tl (hd (tl V5034)))))))) (and (= () (tl (tl (tl (hd (tl V5034)))))) (and (cons? (tl (tl V5034))) (and (cons? (hd (tl (tl V5034)))) (and (= external (hd (hd (tl (tl V5034))))) (and (cons? (tl (hd (tl (tl V5034))))) (and (cons? (hd (tl (hd (tl (tl V5034)))))) (and (= intern (hd (hd (tl (hd (tl (tl V5034))))))) (and (cons? (tl (hd (tl (hd (tl (tl V5034))))))) (and (= "shen" (hd (tl (hd (tl (hd (tl (tl V5034)))))))) (and (= () (tl (tl (hd (tl (hd (tl (tl V5034)))))))) (and (= () (tl (tl (hd (tl (tl V5034)))))) (and (= () (tl (tl (tl V5034)))) (= (hd (tl (hd (tl (tl (hd (tl V5034))))))) (hd (tl (hd (tl V5034)))))))))))))))))))))))))))) (mapcan (lambda F (shen.x.expand-dynamic.expand-lambda-form-entry F)) (value shen.x.expand-dynamic.*external-symbols*))) ((and (cons? V5034) (and (= cons (hd V5034)) (and (cons? (tl V5034)) (and (cons? (hd (tl V5034))) (and (= cons (hd (hd (tl V5034)))) (and (cons? (tl (hd (tl V5034)))) (and (cons? (tl (tl (hd (tl V5034))))) (and (= () (tl (tl (tl (hd (tl V5034)))))) (and (cons? (tl (tl V5034))) (= () (tl (tl (tl V5034))))))))))))) (cons (cons shen.set-lambda-form-entry (cons (hd (tl V5034)) ())) (shen.x.expand-dynamic.expand-lambda-entries (hd (tl (tl V5034)))))) (true (shen.f_error shen.x.expand-dynamic.expand-lambda-entries))))

(defun shen.x.expand-dynamic.get-arity (V5046 V5047) (cond ((= () V5047) -1) ((and (cons? V5047) (and (cons? (tl V5047)) (= (hd V5047) V5046))) (hd (tl V5047))) ((and (cons? V5047) (cons? (tl V5047))) (shen.x.expand-dynamic.get-arity V5046 (tl (tl V5047)))) (true (shen.f_error shen.x.expand-dynamic.get-arity))))

(defun shen.x.expand-dynamic.expand-lambda-form-entry (V5049) (cond ((= package V5049) ()) ((= receive V5049) ()) (true (let ArityF (shen.x.expand-dynamic.get-arity V5049 (value shen.x.expand-dynamic.*arities*)) (if (= ArityF -1) () (if (= ArityF 0) () (cons (cons shen.set-lambda-form-entry (cons (cons cons (cons V5049 (cons (shen.lambda-form V5049 ArityF) ()))) ())) ())))))))

(defun shen.x.expand-dynamic.split-defuns-h (V5052 V5053) (cond ((and (cons? V5052) (and (cons? (hd V5052)) (and (= defun (hd (hd V5052))) (tuple? V5053)))) (shen.x.expand-dynamic.split-defuns-h (tl V5052) (@p (cons (hd V5052) (fst V5053)) (snd V5053)))) ((and (cons? V5052) (tuple? V5053)) (shen.x.expand-dynamic.split-defuns-h (tl V5052) (@p (fst V5053) (cons (hd V5052) (snd V5053))))) ((and (= () V5052) (tuple? V5053)) (@p (reverse (fst V5053)) (reverse (snd V5053)))) (true (shen.f_error shen.x.expand-dynamic.split-defuns-h))))

(defun shen.x.expand-dynamic.split-defuns (V5055) (shen.x.expand-dynamic.split-defuns-h V5055 (@p () ())))

(defun shen.x.expand-dynamic.wrap-in-defun (V5059 V5060 V5061) (cons defun (cons V5059 (cons V5060 (cons (shen.x.expand-dynamic.to-single-expression V5061) ())))))

(defun shen.x.expand-dynamic.to-single-expression (V5063) (cond ((and (cons? V5063) (= () (tl V5063))) (hd V5063)) ((cons? V5063) (cons do (cons (hd V5063) (cons (shen.x.expand-dynamic.to-single-expression (tl V5063)) ())))) (true (shen.f_error shen.x.expand-dynamic.to-single-expression))))



