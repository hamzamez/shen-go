"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.<defprolog> (V837) (let Parse_shen.<predicate*> (shen.<predicate*> V837) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V846 V847) (cond ((and (cons? V847) (and (cons? (tl V847)) (= () (tl (tl V847))))) (simple-error (cn "prolog syntax error in " (shen.app V846 (cn " here:

 " (shen.app (shen.next-50 50 (hd V847)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V846 "
" shen.a))))))

(defun shen.next-50 (V854 V855) (cond ((= () V855) "") ((= 0 V854) "") ((cons? V855) (cn (shen.decons-string (hd V855)) (shen.next-50 (- V854 1) (tl V855)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V857) (cond ((and (cons? V857) (and (= cons (hd V857)) (and (cons? (tl V857)) (and (cons? (tl (tl V857))) (= () (tl (tl (tl V857)))))))) (shen.app (shen.eval-cons V857) " " shen.s)) (true (shen.app V857 " " shen.r))))

(defun shen.insert-predicate (V860 V861) (cond ((and (cons? V861) (and (cons? (tl V861)) (= () (tl (tl V861))))) (cons (cons V860 (hd V861)) (cons :- (tl V861)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V863) (if (cons? (hd V863)) (let Parse_X (shen.hdhd V863) (shen.pair (hd (shen.pair (shen.tlhd V863) (shen.hdtl V863))) Parse_X)) (fail)))

(defun shen.<clauses*> (V865) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V865) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V865) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V868) (let Parse_shen.<head*> (shen.<head*> V868) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (shen.hdhd Parse_shen.<head*>))) (let NewStream866 (shen.pair (shen.tlhd Parse_shen.<head*>) (shen.hdtl Parse_shen.<head*>)) (let Parse_shen.<body*> (shen.<body*> NewStream866) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail)))) (fail)) (fail))))

(defun shen.<head*> (V870) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V870) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V870) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V872) (if (cons? (hd V872)) (let Parse_X (shen.hdhd V872) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (shen.tlhd V872) (shen.hdtl V872))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V878) (cond ((and (cons? V878) (and (= cons (hd V878)) (and (cons? (tl V878)) (and (cons? (tl (tl V878))) (= () (tl (tl (tl V878)))))))) (and (shen.legitimate-term? (hd (tl V878))) (shen.legitimate-term? (hd (tl (tl V878)))))) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (tl (tl V878))) (and (= + (hd (tl (tl V878)))) (= () (tl (tl (tl V878))))))))) (shen.legitimate-term? (hd (tl V878)))) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (tl (tl V878))) (and (= - (hd (tl (tl V878)))) (= () (tl (tl (tl V878))))))))) (shen.legitimate-term? (hd (tl V878)))) ((cons? V878) false) (true true)))

(defun shen.eval-cons (V880) (cond ((and (cons? V880) (and (= cons (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (= () (tl (tl (tl V880)))))))) (cons (shen.eval-cons (hd (tl V880))) (shen.eval-cons (hd (tl (tl V880)))))) ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (= () (tl (tl (tl V880)))))))) (cons mode (cons (shen.eval-cons (hd (tl V880))) (tl (tl V880))))) (true V880)))

(defun shen.<body*> (V882) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V882) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V882) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V885) (let YaccParse (if (and (cons? (hd V885)) (= ! (shen.hdhd V885))) (let NewStream883 (shen.pair (shen.tlhd V885) (shen.hdtl V885)) (shen.pair (hd NewStream883) (cons cut (cons (intern "Throwcontrol") ())))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V885)) (let Parse_X (shen.hdhd V885) (if (cons? Parse_X) (shen.pair (hd (shen.pair (shen.tlhd V885) (shen.hdtl V885))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V887) (if (cons? (hd V887)) (let Parse_X (shen.hdhd V887) (if (= Parse_X ;) (shen.pair (hd (shen.pair (shen.tlhd V887) (shen.hdtl V887))) Parse_X) (fail))) (fail)))

(defun cut (V891 V892 V893) (let Result (thaw V893) (if (= Result false) V891 Result)))

(defun shen.insert_modes (V895) (cond ((and (cons? V895) (and (= mode (hd V895)) (and (cons? (tl V895)) (and (cons? (tl (tl V895))) (= () (tl (tl (tl V895)))))))) V895) ((= () V895) ()) ((cons? V895) (cons (cons mode (cons (hd V895) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V895)) (cons - ()))))) (true V895)))

(defun shen.s-prolog (V897) (map (lambda X (eval X)) (shen.prolog->shen V897)))

(defun shen.prolog->shen (V899) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V899)))))

(defun shen.s-prolog_clause (V901) (cond ((and (cons? V901) (and (cons? (tl V901)) (and (= :- (hd (tl V901))) (and (cons? (tl (tl V901))) (= () (tl (tl (tl V901)))))))) (cons (hd V901) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V901)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V903) (cond ((and (cons? V903) (and (cons? (tl V903)) (and (= :- (hd (tl V903))) (and (cons? (tl (tl V903))) (and (= () (tl (tl (tl V903)))) (trap-error (< (shen.complexity_head (hd V903)) (value shen.*maxcomplexity*)) (lambda _ false))))))) (cons V903 ())) ((and (cons? V903) (and (cons? (hd V903)) (and (cons? (tl V903)) (and (= :- (hd (tl V903))) (and (cons? (tl (tl V903))) (= () (tl (tl (tl V903))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V903))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V903)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V903)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V903)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V909) (cond ((cons? V909) (shen.safe-product (map (lambda X (shen.complexity X)) (tl V909)))) (true (shen.f_error shen.complexity_head))))

(defun shen.safe-multiply (V912 V913) (* V912 V913))

(defun shen.complexity (V922) (cond ((and (cons? V922) (and (= mode (hd V922)) (and (cons? (tl V922)) (and (cons? (hd (tl V922))) (and (= mode (hd (hd (tl V922)))) (and (cons? (tl (hd (tl V922)))) (and (cons? (tl (tl (hd (tl V922))))) (and (= () (tl (tl (tl (hd (tl V922)))))) (and (cons? (tl (tl V922))) (= () (tl (tl (tl V922))))))))))))) (shen.complexity (hd (tl V922)))) ((and (cons? V922) (and (= mode (hd V922)) (and (cons? (tl V922)) (and (cons? (hd (tl V922))) (and (cons? (tl (tl V922))) (and (= + (hd (tl (tl V922)))) (= () (tl (tl (tl V922)))))))))) (shen.safe-multiply 2 (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V922))) (tl (tl V922))))) (shen.complexity (cons mode (cons (tl (hd (tl V922))) (tl (tl V922)))))))) ((and (cons? V922) (and (= mode (hd V922)) (and (cons? (tl V922)) (and (cons? (hd (tl V922))) (and (cons? (tl (tl V922))) (and (= - (hd (tl (tl V922)))) (= () (tl (tl (tl V922)))))))))) (shen.safe-multiply (shen.complexity (cons mode (cons (hd (hd (tl V922))) (tl (tl V922))))) (shen.complexity (cons mode (cons (tl (hd (tl V922))) (tl (tl V922))))))) ((and (cons? V922) (and (= mode (hd V922)) (and (cons? (tl V922)) (and (cons? (tl (tl V922))) (and (= () (tl (tl (tl V922)))) (variable? (hd (tl V922)))))))) 1) ((and (cons? V922) (and (= mode (hd V922)) (and (cons? (tl V922)) (and (cons? (tl (tl V922))) (and (= + (hd (tl (tl V922)))) (= () (tl (tl (tl V922))))))))) 2) ((and (cons? V922) (and (= mode (hd V922)) (and (cons? (tl V922)) (and (cons? (tl (tl V922))) (and (= - (hd (tl (tl V922)))) (= () (tl (tl (tl V922))))))))) 1) (true (shen.complexity (cons mode (cons V922 (cons + ())))))))

(defun shen.safe-product (V924) (cond ((= () V924) 1) ((cons? V924) (shen.safe-multiply (hd V924) (shen.safe-product (tl V924)))) (true (shen.f_error shen.safe-product))))

(defun shen.s-prolog_literal (V926) (cond ((and (cons? V926) (and (= is (hd V926)) (and (cons? (tl V926)) (and (cons? (tl (tl V926))) (= () (tl (tl (tl V926)))))))) (cons bind (cons (hd (tl V926)) (cons (shen.insert-deref (hd (tl (tl V926))) ProcessN) ())))) ((and (cons? V926) (and (= when (hd V926)) (and (cons? (tl V926)) (= () (tl (tl V926)))))) (cons fwhen (cons (shen.insert-deref (hd (tl V926)) ProcessN) ()))) ((and (cons? V926) (and (= bind (hd V926)) (and (cons? (tl V926)) (and (cons? (tl (tl V926))) (= () (tl (tl (tl V926)))))))) (cons bind (cons (hd (tl V926)) (cons (shen.insert-lazyderef (hd (tl (tl V926))) ProcessN) ())))) ((and (cons? V926) (and (= fwhen (hd V926)) (and (cons? (tl V926)) (= () (tl (tl V926)))))) (cons fwhen (cons (shen.insert-lazyderef (hd (tl V926)) ProcessN) ()))) ((cons? V926) V926) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert-deref (V933 V934) (cond ((variable? V933) (cons shen.deref (cons V933 (cons V934 ())))) ((and (cons? V933) (and (= lambda (hd V933)) (and (cons? (tl V933)) (and (cons? (tl (tl V933))) (= () (tl (tl (tl V933)))))))) (cons lambda (cons (hd (tl V933)) (cons (shen.insert-deref (hd (tl (tl V933))) V934) ())))) ((and (cons? V933) (and (= let (hd V933)) (and (cons? (tl V933)) (and (cons? (tl (tl V933))) (and (cons? (tl (tl (tl V933)))) (= () (tl (tl (tl (tl V933)))))))))) (cons let (cons (hd (tl V933)) (cons (shen.insert-deref (hd (tl (tl V933))) V934) (cons (shen.insert-deref (hd (tl (tl (tl V933)))) V934) ()))))) ((cons? V933) (cons (shen.insert-deref (hd V933) V934) (shen.insert-deref (tl V933) V934))) (true V933)))

(defun shen.insert-lazyderef (V941 V942) (cond ((variable? V941) (cons shen.lazyderef (cons V941 (cons V942 ())))) ((and (cons? V941) (and (= lambda (hd V941)) (and (cons? (tl V941)) (and (cons? (tl (tl V941))) (= () (tl (tl (tl V941)))))))) (cons lambda (cons (hd (tl V941)) (cons (shen.insert-lazyderef (hd (tl (tl V941))) V942) ())))) ((and (cons? V941) (and (= let (hd V941)) (and (cons? (tl V941)) (and (cons? (tl (tl V941))) (and (cons? (tl (tl (tl V941)))) (= () (tl (tl (tl (tl V941)))))))))) (cons let (cons (hd (tl V941)) (cons (shen.insert-lazyderef (hd (tl (tl V941))) V942) (cons (shen.insert-lazyderef (hd (tl (tl (tl V941)))) V942) ()))))) ((cons? V941) (cons (shen.insert-lazyderef (hd V941) V942) (shen.insert-lazyderef (tl V941) V942))) (true V941)))

(defun shen.group_clauses (V944) (cond ((= () V944) ()) ((cons? V944) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V944) X)) V944) (let Rest (difference V944 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V949 V950) (cond ((= () V950) ()) ((cons? V950) (if (V949 (hd V950)) (cons (hd V950) (shen.collect V949 (tl V950))) (shen.collect V949 (tl V950)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V969 V970) (cond ((and (cons? V969) (and (cons? (hd V969)) (and (cons? V970) (cons? (hd V970))))) (= (hd (hd V969)) (hd (hd V970)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V972) (let F (shen.procedure_name V972) (let Shen (shen.clauses-to-shen F V972) Shen)))

(defun shen.procedure_name (V986) (cond ((and (cons? V986) (and (cons? (hd V986)) (cons? (hd (hd V986))))) (hd (hd (hd V986)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V989 V990) (let Linear (map (lambda X (shen.linearise-clause X)) V990) (let Arity (shen.prolog-aritycheck V989 (map (lambda X (head X)) V990)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V989 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V992) (cond ((not (shen.occurs? cut V992)) V992) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V992 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1000 V1001) (cond ((= V1001 V1000) false) (true V1001)))

(defun shen.nest-disjunct (V1003) (cond ((and (cons? V1003) (= () (tl V1003))) (hd V1003)) ((cons? V1003) (shen.lisp-or (hd V1003) (shen.nest-disjunct (tl V1003)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V1006 V1007) (cons let (cons Case (cons V1006 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1007 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1012 V1013) (cond ((and (cons? V1013) (= () (tl V1013))) (- (length (hd V1013)) 1)) ((and (cons? V1013) (cons? (tl V1013))) (if (= (length (hd V1013)) (length (hd (tl V1013)))) (shen.prolog-aritycheck V1012 (tl V1013)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1012 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1015) (cond ((and (cons? V1015) (and (cons? (tl V1015)) (and (= :- (hd (tl V1015))) (and (cons? (tl (tl V1015))) (= () (tl (tl (tl V1015)))))))) (let Linear (shen.linearise (cons (hd V1015) (tl (tl V1015)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V1017) (cond ((and (cons? V1017) (and (cons? (tl V1017)) (= () (tl (tl V1017))))) (cons (shen.explicit_modes (hd V1017)) (cons :- (cons (shen.cf_help (hd (tl V1017))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V1019) (cond ((cons? V1019) (cons (hd V1019) (map (lambda X (shen.em_help X)) (tl V1019)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V1021) (cond ((and (cons? V1021) (and (= mode (hd V1021)) (and (cons? (tl V1021)) (and (cons? (tl (tl V1021))) (= () (tl (tl (tl V1021)))))))) V1021) (true (cons mode (cons V1021 (cons + ()))))))

(defun shen.cf_help (V1023) (cond ((and (cons? V1023) (and (= where (hd V1023)) (and (cons? (tl V1023)) (and (cons? (hd (tl V1023))) (and (= = (hd (hd (tl V1023)))) (and (cons? (tl (hd (tl V1023)))) (and (cons? (tl (tl (hd (tl V1023))))) (and (= () (tl (tl (tl (hd (tl V1023)))))) (and (cons? (tl (tl V1023))) (= () (tl (tl (tl V1023))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1023)))) (shen.cf_help (hd (tl (tl V1023)))))) (true V1023)))

(defun occurs-check (V1029) (cond ((= + V1029) (set shen.*occurs* true)) ((= - V1029) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1032 V1033) (cond ((and (cons? V1032) (and (cons? (hd V1032)) (and (cons? (tl V1032)) (and (= :- (hd (tl V1032))) (and (cons? (tl (tl V1032))) (= () (tl (tl (tl V1032))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1032)) (cons (shen.continuation_call (tl (hd V1032)) (hd (tl (tl V1032)))) ()))) V1033) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V1036 V1037) (let VTerms (cons ProcessN (shen.extract_vars V1036)) (let VBody (shen.extract_vars V1037) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1037)))))

(defun remove (V1040 V1041) (shen.remove-h V1040 V1041 ()))

(defun shen.remove-h (V1048 V1049 V1050) (cond ((= () V1049) (reverse V1050)) ((and (cons? V1049) (= (hd V1049) V1048)) (shen.remove-h (hd V1049) (tl V1049) V1050)) ((cons? V1049) (shen.remove-h V1048 (tl V1049) (cons (hd V1049) V1050))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V1053 V1054) (cond ((and (= () V1053) (= () V1054)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1054) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1053 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1053) (cons call (cons shen.the (cons shen.continuation (cons V1054 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1053 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1054 ())))) ())))))))))))

(defun shen.make_mu_application (V1057 V1058) (cond ((and (cons? V1057) (and (= shen.mu (hd V1057)) (and (cons? (tl V1057)) (and (= () (hd (tl V1057))) (and (cons? (tl (tl V1057))) (and (= () (tl (tl (tl V1057)))) (= () V1058))))))) (hd (tl (tl V1057)))) ((and (cons? V1057) (and (= shen.mu (hd V1057)) (and (cons? (tl V1057)) (and (cons? (hd (tl V1057))) (and (cons? (tl (tl V1057))) (and (= () (tl (tl (tl V1057)))) (cons? V1058))))))) (cons (cons shen.mu (cons (hd (hd (tl V1057))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1057))) (tl (tl V1057)))) (tl V1058)) ()))) (cons (hd V1058) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V1067 V1068) (cond ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (hd (tl (hd V1067)))) (and (= mode (hd (hd (tl (hd V1067))))) (and (cons? (tl (hd (tl (hd V1067))))) (and (cons? (tl (tl (hd (tl (hd V1067)))))) (and (= () (tl (tl (tl (hd (tl (hd V1067))))))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (= () (tl (tl V1067))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1067))))) (tl (tl (hd V1067))))) (tl V1067)) (hd (tl (tl (hd (tl (hd V1067)))))))) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (= _ (hd (tl (hd V1067)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1067)))) V1068)) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (shen.ephemeral_variable? (hd (tl (hd V1067))) (hd (tl V1067))))))))))) (subst (hd (tl V1067)) (hd (tl (hd V1067))) (shen.mu_reduction (hd (tl (tl (hd V1067)))) V1068))) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (variable? (hd (tl (hd V1067)))))))))))) (cons let (cons (hd (tl (hd V1067))) (cons shen.be (cons (hd (tl V1067)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1067)))) V1068) ()))))))) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (and (= - V1068) (shen.prolog_constant? (hd (tl (hd V1067))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1067))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1067))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1067)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (and (= + V1068) (shen.prolog_constant? (hd (tl (hd V1067))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1067))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1067))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1067)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1067))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1067)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (hd (tl (hd V1067)))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (= - V1068)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1067))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1067)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1067)))) (tl (tl (hd V1067))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1067) (and (cons? (hd V1067)) (and (= shen.mu (hd (hd V1067))) (and (cons? (tl (hd V1067))) (and (cons? (hd (tl (hd V1067)))) (and (cons? (tl (tl (hd V1067)))) (and (= () (tl (tl (tl (hd V1067))))) (and (cons? (tl V1067)) (and (= () (tl (tl V1067))) (= + V1068)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1067))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1067)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1067)))) (tl (tl (hd V1067))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1067)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1067))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1067)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1067)))

(defun shen.rcons_form (V1070) (cond ((cons? V1070) (cons cons (cons (shen.rcons_form (hd V1070)) (cons (shen.rcons_form (tl V1070)) ())))) (true V1070)))

(defun shen.remove_modes (V1072) (cond ((and (cons? V1072) (and (= mode (hd V1072)) (and (cons? (tl V1072)) (and (cons? (tl (tl V1072))) (and (= + (hd (tl (tl V1072)))) (= () (tl (tl (tl V1072))))))))) (shen.remove_modes (hd (tl V1072)))) ((and (cons? V1072) (and (= mode (hd V1072)) (and (cons? (tl V1072)) (and (cons? (tl (tl V1072))) (and (= - (hd (tl (tl V1072)))) (= () (tl (tl (tl V1072))))))))) (shen.remove_modes (hd (tl V1072)))) ((cons? V1072) (cons (shen.remove_modes (hd V1072)) (shen.remove_modes (tl V1072)))) (true V1072)))

(defun shen.ephemeral_variable? (V1075 V1076) (and (variable? V1075) (variable? V1076)))

(defun shen.prolog_constant? (V1086) (cond ((cons? V1086) false) (true true)))

(defun shen.aum_to_shen (V1088) (cond ((and (cons? V1088) (and (= let (hd V1088)) (and (cons? (tl V1088)) (and (cons? (tl (tl V1088))) (and (= shen.be (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (cons? (tl (tl (tl (tl V1088))))) (and (= in (hd (tl (tl (tl (tl V1088)))))) (and (cons? (tl (tl (tl (tl (tl V1088)))))) (= () (tl (tl (tl (tl (tl (tl V1088)))))))))))))))) (cons let (cons (hd (tl V1088)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1088))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1088))))))) ()))))) ((and (cons? V1088) (and (= shen.the (hd V1088)) (and (cons? (tl V1088)) (and (= shen.result (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.of (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (= shen.dereferencing (hd (tl (tl (tl V1088))))) (and (cons? (tl (tl (tl (tl V1088))))) (= () (tl (tl (tl (tl (tl V1088))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1088)))))) (cons ProcessN ())))) ((and (cons? V1088) (and (= if (hd V1088)) (and (cons? (tl V1088)) (and (cons? (tl (tl V1088))) (and (= shen.then (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (cons? (tl (tl (tl (tl V1088))))) (and (= shen.else (hd (tl (tl (tl (tl V1088)))))) (and (cons? (tl (tl (tl (tl (tl V1088)))))) (= () (tl (tl (tl (tl (tl (tl V1088)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1088))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1088))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1088))))))) ()))))) ((and (cons? V1088) (and (cons? (tl V1088)) (and (= is (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.a (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (= shen.variable (hd (tl (tl (tl V1088))))) (= () (tl (tl (tl (tl V1088)))))))))))) (cons shen.pvar? (cons (hd V1088) ()))) ((and (cons? V1088) (and (cons? (tl V1088)) (and (= is (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.a (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (= shen.non-empty (hd (tl (tl (tl V1088))))) (and (cons? (tl (tl (tl (tl V1088))))) (and (= list (hd (tl (tl (tl (tl V1088)))))) (= () (tl (tl (tl (tl (tl V1088))))))))))))))) (cons cons? (cons (hd V1088) ()))) ((and (cons? V1088) (and (= shen.rename (hd V1088)) (and (cons? (tl V1088)) (and (= shen.the (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.variables (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (= in (hd (tl (tl (tl V1088))))) (and (cons? (tl (tl (tl (tl V1088))))) (and (= () (hd (tl (tl (tl (tl V1088)))))) (and (cons? (tl (tl (tl (tl (tl V1088)))))) (and (= and (hd (tl (tl (tl (tl (tl V1088))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1088))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1088)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1088)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1088)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1088)))))))))) ((and (cons? V1088) (and (= shen.rename (hd V1088)) (and (cons? (tl V1088)) (and (= shen.the (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.variables (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (= in (hd (tl (tl (tl V1088))))) (and (cons? (tl (tl (tl (tl V1088))))) (and (cons? (hd (tl (tl (tl (tl V1088)))))) (and (cons? (tl (tl (tl (tl (tl V1088)))))) (and (= and (hd (tl (tl (tl (tl (tl V1088))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1088))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1088)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1088)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1088)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1088)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1088)))))) (tl (tl (tl (tl (tl V1088))))))))))) ()))))) ((and (cons? V1088) (and (= bind (hd V1088)) (and (cons? (tl V1088)) (and (cons? (tl (tl V1088))) (and (= shen.to (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (cons? (tl (tl (tl (tl V1088))))) (and (= in (hd (tl (tl (tl (tl V1088)))))) (and (cons? (tl (tl (tl (tl (tl V1088)))))) (= () (tl (tl (tl (tl (tl (tl V1088)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1088)) (cons (shen.chwild (hd (tl (tl (tl V1088))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1088))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1088)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1088) (and (cons? (tl V1088)) (and (= is (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= identical (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (and (= shen.to (hd (tl (tl (tl V1088))))) (and (cons? (tl (tl (tl (tl V1088))))) (= () (tl (tl (tl (tl (tl V1088)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1088))))) (cons (hd V1088) ())))) ((= shen.failed! V1088) false) ((and (cons? V1088) (and (= shen.the (hd V1088)) (and (cons? (tl V1088)) (and (= head (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.of (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (= () (tl (tl (tl (tl V1088)))))))))))) (cons hd (tl (tl (tl V1088))))) ((and (cons? V1088) (and (= shen.the (hd V1088)) (and (cons? (tl V1088)) (and (= tail (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.of (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (= () (tl (tl (tl (tl V1088)))))))))))) (cons tl (tl (tl (tl V1088))))) ((and (cons? V1088) (and (= shen.pop (hd V1088)) (and (cons? (tl V1088)) (and (= shen.the (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.stack (hd (tl (tl V1088)))) (= () (tl (tl (tl V1088)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1088) (and (= call (hd V1088)) (and (cons? (tl V1088)) (and (= shen.the (hd (tl V1088))) (and (cons? (tl (tl V1088))) (and (= shen.continuation (hd (tl (tl V1088)))) (and (cons? (tl (tl (tl V1088)))) (= () (tl (tl (tl (tl V1088)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1088))))) ProcessN Continuation) ())))) (true V1088)))

(defun shen.chwild (V1090) (cond ((= V1090 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1090) (map (lambda Z (shen.chwild Z)) V1090)) (true V1090)))

(defun shen.newpv (V1092) (let Count+1 (+ (<-address (value shen.*varcounter*) V1092) 1) (let IncVar (address-> (value shen.*varcounter*) V1092 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1092) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1092 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1095 V1096) (let Vector (<-address (value shen.*prologvectors*) V1095) (let BigVector (shen.resize-vector Vector (+ V1096 V1096) shen.-null-) (address-> (value shen.*prologvectors*) V1095 BigVector))))

(defun shen.resize-vector (V1100 V1101 V1102) (let BigVector (address-> (absvector (+ 1 V1101)) 0 V1101) (shen.copy-vector V1100 BigVector (limit V1100) V1101 V1102)))

(defun shen.copy-vector (V1108 V1109 V1110 V1111 V1112) (shen.copy-vector-stage-2 (+ 1 V1110) (+ V1111 1) V1112 (shen.copy-vector-stage-1 1 V1108 V1109 (+ 1 V1110))))

(defun shen.copy-vector-stage-1 (V1120 V1121 V1122 V1123) (cond ((= V1123 V1120) V1122) (true (shen.copy-vector-stage-1 (+ 1 V1120) V1121 (address-> V1122 V1120 (<-address V1121 V1120)) V1123))))

(defun shen.copy-vector-stage-2 (V1131 V1132 V1133 V1134) (cond ((= V1132 V1131) V1134) (true (shen.copy-vector-stage-2 (+ V1131 1) V1132 V1133 (address-> V1134 V1131 V1133)))))

(defun shen.mk-pvar (V1136) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1136))

(defun shen.pvar? (V1138) (and (absvector? V1138) (= (trap-error (<-address V1138 0) (lambda E shen.not-pvar)) shen.pvar)))

(defun shen.bindv (V1142 V1143 V1144) (let Vector (<-address (value shen.*prologvectors*) V1144) (address-> Vector (<-address V1142 1) V1143)))

(defun shen.unbindv (V1147 V1148) (let Vector (<-address (value shen.*prologvectors*) V1148) (address-> Vector (<-address V1147 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1152 V1153 V1154) (cond ((and (cons? V1152) (and (cons? (hd V1152)) (= () (tl V1152)))) (cons (hd (hd V1152)) (append (tl (hd V1152)) (cons V1153 (cons V1154 ()))))) ((and (cons? V1152) (cons? (hd V1152))) (let NewContinuation (shen.newcontinuation (tl V1152) V1153 V1154) (cons (hd (hd V1152)) (append (tl (hd V1152)) (cons V1153 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1158 V1159 V1160) (cond ((= () V1158) V1160) ((and (cons? V1158) (cons? (hd V1158))) (cons freeze (cons (cons (hd (hd V1158)) (append (tl (hd V1158)) (cons V1159 (cons (shen.newcontinuation (tl V1158) V1159 V1160) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1168 V1169 V1170) (shen.deref V1168 V1169))

(defun shen.measure&return (V1178 V1179 V1180) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1178 V1179)))

(defun unify (V1185 V1186 V1187 V1188) (shen.lzy= (shen.lazyderef V1185 V1187) (shen.lazyderef V1186 V1187) V1187 V1188))

(defun shen.lzy= (V1210 V1211 V1212 V1213) (cond ((= V1211 V1210) (thaw V1213)) ((shen.pvar? V1210) (bind V1210 V1211 V1212 V1213)) ((shen.pvar? V1211) (bind V1211 V1210 V1212 V1213)) ((and (cons? V1210) (cons? V1211)) (shen.lzy= (shen.lazyderef (hd V1210) V1212) (shen.lazyderef (hd V1211) V1212) V1212 (freeze (shen.lzy= (shen.lazyderef (tl V1210) V1212) (shen.lazyderef (tl V1211) V1212) V1212 V1213)))) (true false)))

(defun shen.deref (V1216 V1217) (cond ((cons? V1216) (cons (shen.deref (hd V1216) V1217) (shen.deref (tl V1216) V1217))) (true (if (shen.pvar? V1216) (let Value (shen.valvector V1216 V1217) (if (= Value shen.-null-) V1216 (shen.deref Value V1217))) V1216))))

(defun shen.lazyderef (V1220 V1221) (if (shen.pvar? V1220) (let Value (shen.valvector V1220 V1221) (if (= Value shen.-null-) V1220 (shen.lazyderef Value V1221))) V1220))

(defun shen.valvector (V1224 V1225) (<-address (<-address (value shen.*prologvectors*) V1225) (<-address V1224 1)))

(defun unify! (V1230 V1231 V1232 V1233) (shen.lzy=! (shen.lazyderef V1230 V1232) (shen.lazyderef V1231 V1232) V1232 V1233))

(defun shen.lzy=! (V1255 V1256 V1257 V1258) (cond ((= V1256 V1255) (thaw V1258)) ((and (shen.pvar? V1255) (not (shen.occurs? V1255 (shen.deref V1256 V1257)))) (bind V1255 V1256 V1257 V1258)) ((and (shen.pvar? V1256) (not (shen.occurs? V1256 (shen.deref V1255 V1257)))) (bind V1256 V1255 V1257 V1258)) ((and (cons? V1255) (cons? V1256)) (shen.lzy=! (shen.lazyderef (hd V1255) V1257) (shen.lazyderef (hd V1256) V1257) V1257 (freeze (shen.lzy=! (shen.lazyderef (tl V1255) V1257) (shen.lazyderef (tl V1256) V1257) V1257 V1258)))) (true false)))

(defun shen.occurs? (V1270 V1271) (cond ((= V1271 V1270) true) ((cons? V1271) (or (shen.occurs? V1270 (hd V1271)) (shen.occurs? V1270 (tl V1271)))) (true false)))

(defun identical (V1276 V1277 V1278 V1279) (shen.lzy== (shen.lazyderef V1276 V1278) (shen.lazyderef V1277 V1278) V1278 V1279))

(defun shen.lzy== (V1301 V1302 V1303 V1304) (cond ((= V1302 V1301) (thaw V1304)) ((and (cons? V1301) (cons? V1302)) (shen.lzy== (shen.lazyderef (hd V1301) V1303) (shen.lazyderef (hd V1302) V1303) V1303 (freeze (shen.lzy== (tl V1301) (tl V1302) V1303 V1304)))) (true false)))

(defun shen.pvar (V1306) (cn "Var" (shen.app (<-address V1306 1) "" shen.a)))

(defun bind (V1311 V1312 V1313 V1314) (do (shen.bindv V1311 V1312 V1313) (let Result (thaw V1314) (do (shen.unbindv V1311 V1313) Result))))

(defun fwhen (V1332 V1333 V1334) (cond ((= true V1332) (thaw V1334)) ((= false V1332) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1332 "%" shen.s))))))

(defun call (V1350 V1351 V1352) (cond ((cons? V1350) (shen.call-help (function (shen.lazyderef (hd V1350) V1351)) (tl V1350) V1351 V1352)) ((shen.pvar? V1350) (call (shen.lazyderef V1350 V1351) V1351 V1352)) (true false)))

(defun shen.call-help (V1357 V1358 V1359 V1360) (cond ((= () V1358) (V1357 V1359 V1360)) ((cons? V1358) (shen.call-help (V1357 (hd V1358)) (tl V1358) V1359 V1360)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V1362) (cond ((and (cons? V1362) (cons? (hd V1362))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1362)) (shen.insert-prolog-variables (cons (tl (hd V1362)) (cons (tl V1362) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V1366 V1367 V1368) (cond ((and (cons? V1367) (and (cons? (tl V1367)) (= () (tl (tl V1367))))) (shen.intprolog-help-help V1366 (hd V1367) (hd (tl V1367)) V1368)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1373 V1374 V1375 V1376) (cond ((= () V1374) (V1373 V1376 (freeze (shen.call-rest V1375 V1376)))) ((cons? V1374) (shen.intprolog-help-help (V1373 (hd V1374)) (tl V1374) V1375 V1376)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V1381 V1382) (cond ((= () V1381) true) ((and (cons? V1381) (and (cons? (hd V1381)) (cons? (tl (hd V1381))))) (shen.call-rest (cons (cons ((hd (hd V1381)) (hd (tl (hd V1381)))) (tl (tl (hd V1381)))) (tl V1381)) V1382)) ((and (cons? V1381) (and (cons? (hd V1381)) (= () (tl (hd V1381))))) ((hd (hd V1381)) V1382 (freeze (shen.call-rest (tl V1381) V1382)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1385 V1386) (shen.insert-prolog-variables-help V1385 (shen.flatten V1385) V1386))

(defun shen.insert-prolog-variables-help (V1394 V1395 V1396) (cond ((= () V1395) V1394) ((and (cons? V1395) (variable? (hd V1395))) (let V (shen.newpv V1396) (let XV/Y (subst V (hd V1395) V1394) (let Z-Y (remove (hd V1395) (tl V1395)) (shen.insert-prolog-variables-help XV/Y Z-Y V1396))))) ((cons? V1395) (shen.insert-prolog-variables-help V1394 (tl V1395) V1396)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1398) (let Vector (address-> (value shen.*prologvectors*) V1398 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1398 1) V1398)))



