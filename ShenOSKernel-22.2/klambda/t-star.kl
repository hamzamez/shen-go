"Copyright (c) 2010-2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ''AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"

(defun shen.typecheck (V2701 V2702) (let Curry (shen.curry V2701) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2702)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2704) (cond ((and (cons? V2704) (shen.special? (hd V2704))) (cons (hd V2704) (map (lambda Y (shen.curry Y)) (tl V2704)))) ((and (cons? V2704) (and (cons? (tl V2704)) (shen.extraspecial? (hd V2704)))) V2704) ((and (cons? V2704) (and (= type (hd V2704)) (and (cons? (tl V2704)) (and (cons? (tl (tl V2704))) (= () (tl (tl (tl V2704)))))))) (cons type (cons (shen.curry (hd (tl V2704))) (tl (tl V2704))))) ((and (cons? V2704) (and (cons? (tl V2704)) (cons? (tl (tl V2704))))) (shen.curry (cons (cons (hd V2704) (cons (hd (tl V2704)) ())) (tl (tl V2704))))) ((and (cons? V2704) (and (cons? (tl V2704)) (= () (tl (tl V2704))))) (cons (shen.curry (hd V2704)) (cons (shen.curry (hd (tl V2704))) ()))) (true V2704)))

(defun shen.special? (V2706) (element? V2706 (value shen.*special*)))

(defun shen.extraspecial? (V2708) (element? V2708 (value shen.*extraspecial*)))

(defun shen.t* (V2713 V2714 V2715 V2716) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2715) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2715 (freeze (bind Error (shen.errormaxinfs) V2715 V2716))))) (if (= Case false) (let Case (let V2693 (shen.lazyderef V2713 V2715) (if (= fail V2693) (do (shen.incinfs) (cut Throwcontrol V2715 (freeze (shen.prolog-failure V2715 V2716)))) false)) (if (= Case false) (let Case (let V2694 (shen.lazyderef V2713 V2715) (if (cons? V2694) (let X (hd V2694) (let V2695 (shen.lazyderef (tl V2694) V2715) (if (cons? V2695) (let V2696 (shen.lazyderef (hd V2695) V2715) (if (= : V2696) (let V2697 (shen.lazyderef (tl V2695) V2715) (if (cons? V2697) (let A (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2715) (if (= () V2698) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2715 (freeze (cut Throwcontrol V2715 (freeze (shen.th* X A V2714 V2715 V2716)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2715) (do (shen.incinfs) (shen.show V2713 V2714 V2715 (freeze (bind Datatypes (value shen.*datatypes*) V2715 (freeze (shen.udefs* V2713 V2714 Datatypes V2715 V2716))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2722) (cond ((= + V2722) (set shen.*shen-type-theory-enabled?* true)) ((= - V2722) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2733 V2734) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2740 V2741 V2742 V2743 V2744) (let Case (let V2689 (shen.lazyderef V2742 V2743) (if (cons? V2689) (let D (hd V2689) (do (shen.incinfs) (call (cons D (cons V2740 (cons V2741 ()))) V2743 V2744))) false)) (if (= Case false) (let V2690 (shen.lazyderef V2742 V2743) (if (cons? V2690) (let Ds (tl V2690) (do (shen.incinfs) (shen.udefs* V2740 V2741 Ds V2743 V2744))) false)) Case)))

(defun shen.th* (V2750 V2751 V2752 V2753 V2754) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2750 (cons : (cons V2751 ()))) V2752 V2753 (freeze (fwhen false V2753 V2754)))) (if (= Case false) (let Case (let F (shen.newpv V2753) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2750 V2753)) V2753 (freeze (bind F (shen.sigf (shen.lazyderef V2750 V2753)) V2753 (freeze (call (cons F (cons V2751 ())) V2753 V2754))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2750 V2751 V2753 V2754)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2750 V2751 V2752 V2753 V2754)) (if (= Case false) (let Case (let V2585 (shen.lazyderef V2750 V2753) (if (cons? V2585) (let F (hd V2585) (let V2586 (shen.lazyderef (tl V2585) V2753) (if (= () V2586) (do (shen.incinfs) (shen.th* F (cons --> (cons V2751 ())) V2752 V2753 V2754)) false))) false)) (if (= Case false) (let Case (let V2587 (shen.lazyderef V2750 V2753) (if (cons? V2587) (let F (hd V2587) (let V2588 (shen.lazyderef (tl V2587) V2753) (if (cons? V2588) (let X (hd V2588) (let V2589 (shen.lazyderef (tl V2588) V2753) (if (= () V2589) (let B (shen.newpv V2753) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2751 ()))) V2752 V2753 (freeze (shen.th* X B V2752 V2753 V2754))))) false))) false))) false)) (if (= Case false) (let Case (let V2590 (shen.lazyderef V2750 V2753) (if (cons? V2590) (let V2591 (shen.lazyderef (hd V2590) V2753) (if (= cons V2591) (let V2592 (shen.lazyderef (tl V2590) V2753) (if (cons? V2592) (let X (hd V2592) (let V2593 (shen.lazyderef (tl V2592) V2753) (if (cons? V2593) (let Y (hd V2593) (let V2594 (shen.lazyderef (tl V2593) V2753) (if (= () V2594) (let V2595 (shen.lazyderef V2751 V2753) (if (cons? V2595) (let V2596 (shen.lazyderef (hd V2595) V2753) (if (= list V2596) (let V2597 (shen.lazyderef (tl V2595) V2753) (if (cons? V2597) (let A (hd V2597) (let V2598 (shen.lazyderef (tl V2597) V2753) (if (= () V2598) (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (if (shen.pvar? V2598) (do (shen.bindv V2598 () V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2598 V2753) Result))) false)))) (if (shen.pvar? V2597) (let A (shen.newpv V2753) (do (shen.bindv V2597 (cons A ()) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2597 V2753) Result)))) false))) (if (shen.pvar? V2596) (do (shen.bindv V2596 list V2753) (let Result (let V2599 (shen.lazyderef (tl V2595) V2753) (if (cons? V2599) (let A (hd V2599) (let V2600 (shen.lazyderef (tl V2599) V2753) (if (= () V2600) (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (if (shen.pvar? V2600) (do (shen.bindv V2600 () V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2600 V2753) Result))) false)))) (if (shen.pvar? V2599) (let A (shen.newpv V2753) (do (shen.bindv V2599 (cons A ()) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2599 V2753) Result)))) false))) (do (shen.unbindv V2596 V2753) Result))) false))) (if (shen.pvar? V2595) (let A (shen.newpv V2753) (do (shen.bindv V2595 (cons list (cons A ())) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons list (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2595 V2753) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2601 (shen.lazyderef V2750 V2753) (if (cons? V2601) (let V2602 (shen.lazyderef (hd V2601) V2753) (if (= @p V2602) (let V2603 (shen.lazyderef (tl V2601) V2753) (if (cons? V2603) (let X (hd V2603) (let V2604 (shen.lazyderef (tl V2603) V2753) (if (cons? V2604) (let Y (hd V2604) (let V2605 (shen.lazyderef (tl V2604) V2753) (if (= () V2605) (let V2606 (shen.lazyderef V2751 V2753) (if (cons? V2606) (let A (hd V2606) (let V2607 (shen.lazyderef (tl V2606) V2753) (if (cons? V2607) (let V2608 (shen.lazyderef (hd V2607) V2753) (if (= * V2608) (let V2609 (shen.lazyderef (tl V2607) V2753) (if (cons? V2609) (let B (hd V2609) (let V2610 (shen.lazyderef (tl V2609) V2753) (if (= () V2610) (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (if (shen.pvar? V2610) (do (shen.bindv V2610 () V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (do (shen.unbindv V2610 V2753) Result))) false)))) (if (shen.pvar? V2609) (let B (shen.newpv V2753) (do (shen.bindv V2609 (cons B ()) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (do (shen.unbindv V2609 V2753) Result)))) false))) (if (shen.pvar? V2608) (do (shen.bindv V2608 * V2753) (let Result (let V2611 (shen.lazyderef (tl V2607) V2753) (if (cons? V2611) (let B (hd V2611) (let V2612 (shen.lazyderef (tl V2611) V2753) (if (= () V2612) (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (if (shen.pvar? V2612) (do (shen.bindv V2612 () V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (do (shen.unbindv V2612 V2753) Result))) false)))) (if (shen.pvar? V2611) (let B (shen.newpv V2753) (do (shen.bindv V2611 (cons B ()) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (do (shen.unbindv V2611 V2753) Result)))) false))) (do (shen.unbindv V2608 V2753) Result))) false))) (if (shen.pvar? V2607) (let B (shen.newpv V2753) (do (shen.bindv V2607 (cons * (cons B ())) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (do (shen.unbindv V2607 V2753) Result)))) false)))) (if (shen.pvar? V2606) (let A (shen.newpv V2753) (let B (shen.newpv V2753) (do (shen.bindv V2606 (cons A (cons * (cons B ()))) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y B V2752 V2753 V2754)))) (do (shen.unbindv V2606 V2753) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2613 (shen.lazyderef V2750 V2753) (if (cons? V2613) (let V2614 (shen.lazyderef (hd V2613) V2753) (if (= @v V2614) (let V2615 (shen.lazyderef (tl V2613) V2753) (if (cons? V2615) (let X (hd V2615) (let V2616 (shen.lazyderef (tl V2615) V2753) (if (cons? V2616) (let Y (hd V2616) (let V2617 (shen.lazyderef (tl V2616) V2753) (if (= () V2617) (let V2618 (shen.lazyderef V2751 V2753) (if (cons? V2618) (let V2619 (shen.lazyderef (hd V2618) V2753) (if (= vector V2619) (let V2620 (shen.lazyderef (tl V2618) V2753) (if (cons? V2620) (let A (hd V2620) (let V2621 (shen.lazyderef (tl V2620) V2753) (if (= () V2621) (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (if (shen.pvar? V2621) (do (shen.bindv V2621 () V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2621 V2753) Result))) false)))) (if (shen.pvar? V2620) (let A (shen.newpv V2753) (do (shen.bindv V2620 (cons A ()) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2620 V2753) Result)))) false))) (if (shen.pvar? V2619) (do (shen.bindv V2619 vector V2753) (let Result (let V2622 (shen.lazyderef (tl V2618) V2753) (if (cons? V2622) (let A (hd V2622) (let V2623 (shen.lazyderef (tl V2622) V2753) (if (= () V2623) (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (if (shen.pvar? V2623) (do (shen.bindv V2623 () V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2623 V2753) Result))) false)))) (if (shen.pvar? V2622) (let A (shen.newpv V2753) (do (shen.bindv V2622 (cons A ()) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2622 V2753) Result)))) false))) (do (shen.unbindv V2619 V2753) Result))) false))) (if (shen.pvar? V2618) (let A (shen.newpv V2753) (do (shen.bindv V2618 (cons vector (cons A ())) V2753) (let Result (do (shen.incinfs) (shen.th* X A V2752 V2753 (freeze (shen.th* Y (cons vector (cons A ())) V2752 V2753 V2754)))) (do (shen.unbindv V2618 V2753) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2624 (shen.lazyderef V2750 V2753) (if (cons? V2624) (let V2625 (shen.lazyderef (hd V2624) V2753) (if (= @s V2625) (let V2626 (shen.lazyderef (tl V2624) V2753) (if (cons? V2626) (let X (hd V2626) (let V2627 (shen.lazyderef (tl V2626) V2753) (if (cons? V2627) (let Y (hd V2627) (let V2628 (shen.lazyderef (tl V2627) V2753) (if (= () V2628) (let V2629 (shen.lazyderef V2751 V2753) (if (= string V2629) (do (shen.incinfs) (shen.th* X string V2752 V2753 (freeze (shen.th* Y string V2752 V2753 V2754)))) (if (shen.pvar? V2629) (do (shen.bindv V2629 string V2753) (let Result (do (shen.incinfs) (shen.th* X string V2752 V2753 (freeze (shen.th* Y string V2752 V2753 V2754)))) (do (shen.unbindv V2629 V2753) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2630 (shen.lazyderef V2750 V2753) (if (cons? V2630) (let V2631 (shen.lazyderef (hd V2630) V2753) (if (= lambda V2631) (let V2632 (shen.lazyderef (tl V2630) V2753) (if (cons? V2632) (let X (hd V2632) (let V2633 (shen.lazyderef (tl V2632) V2753) (if (cons? V2633) (let Y (hd V2633) (let V2634 (shen.lazyderef (tl V2633) V2753) (if (= () V2634) (let V2635 (shen.lazyderef V2751 V2753) (if (cons? V2635) (let A (hd V2635) (let V2636 (shen.lazyderef (tl V2635) V2753) (if (cons? V2636) (let V2637 (shen.lazyderef (hd V2636) V2753) (if (= --> V2637) (let V2638 (shen.lazyderef (tl V2636) V2753) (if (cons? V2638) (let B (hd V2638) (let V2639 (shen.lazyderef (tl V2638) V2753) (if (= () V2639) (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (if (shen.pvar? V2639) (do (shen.bindv V2639 () V2753) (let Result (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (do (shen.unbindv V2639 V2753) Result))) false)))) (if (shen.pvar? V2638) (let B (shen.newpv V2753) (do (shen.bindv V2638 (cons B ()) V2753) (let Result (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (do (shen.unbindv V2638 V2753) Result)))) false))) (if (shen.pvar? V2637) (do (shen.bindv V2637 --> V2753) (let Result (let V2640 (shen.lazyderef (tl V2636) V2753) (if (cons? V2640) (let B (hd V2640) (let V2641 (shen.lazyderef (tl V2640) V2753) (if (= () V2641) (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (if (shen.pvar? V2641) (do (shen.bindv V2641 () V2753) (let Result (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (do (shen.unbindv V2641 V2753) Result))) false)))) (if (shen.pvar? V2640) (let B (shen.newpv V2753) (do (shen.bindv V2640 (cons B ()) V2753) (let Result (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (do (shen.unbindv V2640 V2753) Result)))) false))) (do (shen.unbindv V2637 V2753) Result))) false))) (if (shen.pvar? V2636) (let B (shen.newpv V2753) (do (shen.bindv V2636 (cons --> (cons B ())) V2753) (let Result (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (do (shen.unbindv V2636 V2753) Result)))) false)))) (if (shen.pvar? V2635) (let A (shen.newpv V2753) (let B (shen.newpv V2753) (do (shen.bindv V2635 (cons A (cons --> (cons B ()))) V2753) (let Result (let Z (shen.newpv V2753) (let X&& (shen.newpv V2753) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Y V2753)) V2753 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2752) V2753 V2754)))))))))) (do (shen.unbindv V2635 V2753) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2642 (shen.lazyderef V2750 V2753) (if (cons? V2642) (let V2643 (shen.lazyderef (hd V2642) V2753) (if (= let V2643) (let V2644 (shen.lazyderef (tl V2642) V2753) (if (cons? V2644) (let X (hd V2644) (let V2645 (shen.lazyderef (tl V2644) V2753) (if (cons? V2645) (let Y (hd V2645) (let V2646 (shen.lazyderef (tl V2645) V2753) (if (cons? V2646) (let Z (hd V2646) (let V2647 (shen.lazyderef (tl V2646) V2753) (if (= () V2647) (let W (shen.newpv V2753) (let X&& (shen.newpv V2753) (let B (shen.newpv V2753) (do (shen.incinfs) (shen.th* Y B V2752 V2753 (freeze (bind X&& (shen.placeholder) V2753 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2753) (shen.lazyderef X V2753) (shen.lazyderef Z V2753)) V2753 (freeze (shen.th* W V2751 (cons (cons X&& (cons : (cons B ()))) V2752) V2753 V2754))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2648 (shen.lazyderef V2750 V2753) (if (cons? V2648) (let V2649 (shen.lazyderef (hd V2648) V2753) (if (= open V2649) (let V2650 (shen.lazyderef (tl V2648) V2753) (if (cons? V2650) (let FileName (hd V2650) (let V2651 (shen.lazyderef (tl V2650) V2753) (if (cons? V2651) (let Direction2581 (hd V2651) (let V2652 (shen.lazyderef (tl V2651) V2753) (if (= () V2652) (let V2653 (shen.lazyderef V2751 V2753) (if (cons? V2653) (let V2654 (shen.lazyderef (hd V2653) V2753) (if (= stream V2654) (let V2655 (shen.lazyderef (tl V2653) V2753) (if (cons? V2655) (let Direction (hd V2655) (let V2656 (shen.lazyderef (tl V2655) V2753) (if (= () V2656) (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (if (shen.pvar? V2656) (do (shen.bindv V2656 () V2753) (let Result (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (do (shen.unbindv V2656 V2753) Result))) false)))) (if (shen.pvar? V2655) (let Direction (shen.newpv V2753) (do (shen.bindv V2655 (cons Direction ()) V2753) (let Result (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (do (shen.unbindv V2655 V2753) Result)))) false))) (if (shen.pvar? V2654) (do (shen.bindv V2654 stream V2753) (let Result (let V2657 (shen.lazyderef (tl V2653) V2753) (if (cons? V2657) (let Direction (hd V2657) (let V2658 (shen.lazyderef (tl V2657) V2753) (if (= () V2658) (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (if (shen.pvar? V2658) (do (shen.bindv V2658 () V2753) (let Result (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (do (shen.unbindv V2658 V2753) Result))) false)))) (if (shen.pvar? V2657) (let Direction (shen.newpv V2753) (do (shen.bindv V2657 (cons Direction ()) V2753) (let Result (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (do (shen.unbindv V2657 V2753) Result)))) false))) (do (shen.unbindv V2654 V2753) Result))) false))) (if (shen.pvar? V2653) (let Direction (shen.newpv V2753) (do (shen.bindv V2653 (cons stream (cons Direction ())) V2753) (let Result (do (shen.incinfs) (unify! Direction Direction2581 V2753 (freeze (cut Throwcontrol V2753 (freeze (fwhen (element? (shen.lazyderef Direction V2753) (cons in (cons out ()))) V2753 (freeze (shen.th* FileName string V2752 V2753 V2754)))))))) (do (shen.unbindv V2653 V2753) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2659 (shen.lazyderef V2750 V2753) (if (cons? V2659) (let V2660 (shen.lazyderef (hd V2659) V2753) (if (= type V2660) (let V2661 (shen.lazyderef (tl V2659) V2753) (if (cons? V2661) (let X (hd V2661) (let V2662 (shen.lazyderef (tl V2661) V2753) (if (cons? V2662) (let A (hd V2662) (let V2663 (shen.lazyderef (tl V2662) V2753) (if (= () V2663) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (unify A V2751 V2753 (freeze (shen.th* X A V2752 V2753 V2754)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2664 (shen.lazyderef V2750 V2753) (if (cons? V2664) (let V2665 (shen.lazyderef (hd V2664) V2753) (if (= input+ V2665) (let V2666 (shen.lazyderef (tl V2664) V2753) (if (cons? V2666) (let A (hd V2666) (let V2667 (shen.lazyderef (tl V2666) V2753) (if (cons? V2667) (let Stream (hd V2667) (let V2668 (shen.lazyderef (tl V2667) V2753) (if (= () V2668) (let C (shen.newpv V2753) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2753)) V2753 (freeze (unify V2751 C V2753 (freeze (shen.th* Stream (cons stream (cons in ())) V2752 V2753 V2754))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2669 (shen.lazyderef V2750 V2753) (if (cons? V2669) (let V2670 (shen.lazyderef (hd V2669) V2753) (if (= set V2670) (let V2671 (shen.lazyderef (tl V2669) V2753) (if (cons? V2671) (let Var (hd V2671) (let V2672 (shen.lazyderef (tl V2671) V2753) (if (cons? V2672) (let Val (hd V2672) (let V2673 (shen.lazyderef (tl V2672) V2753) (if (= () V2673) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (shen.th* Var symbol V2752 V2753 (freeze (cut Throwcontrol V2753 (freeze (shen.th* (cons value (cons Var ())) V2751 V2752 V2753 (freeze (shen.th* Val V2751 V2752 V2753 V2754)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2753) (do (shen.incinfs) (shen.t*-hyps V2752 NewHyp V2753 (freeze (shen.th* V2750 V2751 NewHyp V2753 V2754))))) (if (= Case false) (let Case (let V2674 (shen.lazyderef V2750 V2753) (if (cons? V2674) (let V2675 (shen.lazyderef (hd V2674) V2753) (if (= define V2675) (let V2676 (shen.lazyderef (tl V2674) V2753) (if (cons? V2676) (let F (hd V2676) (let X (tl V2676) (do (shen.incinfs) (cut Throwcontrol V2753 (freeze (shen.t*-def (cons define (cons F X)) V2751 V2752 V2753 V2754)))))) false)) false)) false)) (if (= Case false) (let Case (let V2677 (shen.lazyderef V2750 V2753) (if (cons? V2677) (let V2678 (shen.lazyderef (hd V2677) V2753) (if (= defmacro V2678) (let V2679 (shen.lazyderef V2751 V2753) (if (= unit V2679) (do (shen.incinfs) (cut Throwcontrol V2753 V2754)) (if (shen.pvar? V2679) (do (shen.bindv V2679 unit V2753) (let Result (do (shen.incinfs) (cut Throwcontrol V2753 V2754)) (do (shen.unbindv V2679 V2753) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2680 (shen.lazyderef V2750 V2753) (if (cons? V2680) (let V2681 (shen.lazyderef (hd V2680) V2753) (if (= shen.process-datatype V2681) (let V2682 (shen.lazyderef V2751 V2753) (if (= symbol V2682) (do (shen.incinfs) (thaw V2754)) (if (shen.pvar? V2682) (do (shen.bindv V2682 symbol V2753) (let Result (do (shen.incinfs) (thaw V2754)) (do (shen.unbindv V2682 V2753) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2683 (shen.lazyderef V2750 V2753) (if (cons? V2683) (let V2684 (shen.lazyderef (hd V2683) V2753) (if (= shen.synonyms-help V2684) (let V2685 (shen.lazyderef V2751 V2753) (if (= symbol V2685) (do (shen.incinfs) (thaw V2754)) (if (shen.pvar? V2685) (do (shen.bindv V2685 symbol V2753) (let Result (do (shen.incinfs) (thaw V2754)) (do (shen.unbindv V2685 V2753) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2753) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2753 (freeze (shen.udefs* (cons V2750 (cons : (cons V2751 ()))) V2752 Datatypes V2753 V2754))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2759 V2760 V2761 V2762) (let Case (let V2496 (shen.lazyderef V2759 V2761) (if (cons? V2496) (let V2497 (shen.lazyderef (hd V2496) V2761) (if (cons? V2497) (let V2498 (shen.lazyderef (hd V2497) V2761) (if (cons? V2498) (let V2499 (shen.lazyderef (hd V2498) V2761) (if (= cons V2499) (let V2500 (shen.lazyderef (tl V2498) V2761) (if (cons? V2500) (let X (hd V2500) (let V2501 (shen.lazyderef (tl V2500) V2761) (if (cons? V2501) (let Y (hd V2501) (let V2502 (shen.lazyderef (tl V2501) V2761) (if (= () V2502) (let V2503 (shen.lazyderef (tl V2497) V2761) (if (cons? V2503) (let V2504 (shen.lazyderef (hd V2503) V2761) (if (= : V2504) (let V2505 (shen.lazyderef (tl V2503) V2761) (if (cons? V2505) (let V2506 (shen.lazyderef (hd V2505) V2761) (if (cons? V2506) (let V2507 (shen.lazyderef (hd V2506) V2761) (if (= list V2507) (let V2508 (shen.lazyderef (tl V2506) V2761) (if (cons? V2508) (let A (hd V2508) (let V2509 (shen.lazyderef (tl V2508) V2761) (if (= () V2509) (let V2510 (shen.lazyderef (tl V2505) V2761) (if (= () V2510) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2510) (do (shen.bindv V2510 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2510 V2761) Result))) false))) (if (shen.pvar? V2509) (do (shen.bindv V2509 () V2761) (let Result (let V2511 (shen.lazyderef (tl V2505) V2761) (if (= () V2511) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2511) (do (shen.bindv V2511 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2511 V2761) Result))) false))) (do (shen.unbindv V2509 V2761) Result))) false)))) (if (shen.pvar? V2508) (let A (shen.newpv V2761) (do (shen.bindv V2508 (cons A ()) V2761) (let Result (let V2512 (shen.lazyderef (tl V2505) V2761) (if (= () V2512) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2512) (do (shen.bindv V2512 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2512 V2761) Result))) false))) (do (shen.unbindv V2508 V2761) Result)))) false))) (if (shen.pvar? V2507) (do (shen.bindv V2507 list V2761) (let Result (let V2513 (shen.lazyderef (tl V2506) V2761) (if (cons? V2513) (let A (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2761) (if (= () V2514) (let V2515 (shen.lazyderef (tl V2505) V2761) (if (= () V2515) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2515) (do (shen.bindv V2515 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2515 V2761) Result))) false))) (if (shen.pvar? V2514) (do (shen.bindv V2514 () V2761) (let Result (let V2516 (shen.lazyderef (tl V2505) V2761) (if (= () V2516) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2516) (do (shen.bindv V2516 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2516 V2761) Result))) false))) (do (shen.unbindv V2514 V2761) Result))) false)))) (if (shen.pvar? V2513) (let A (shen.newpv V2761) (do (shen.bindv V2513 (cons A ()) V2761) (let Result (let V2517 (shen.lazyderef (tl V2505) V2761) (if (= () V2517) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2517) (do (shen.bindv V2517 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2517 V2761) Result))) false))) (do (shen.unbindv V2513 V2761) Result)))) false))) (do (shen.unbindv V2507 V2761) Result))) false))) (if (shen.pvar? V2506) (let A (shen.newpv V2761) (do (shen.bindv V2506 (cons list (cons A ())) V2761) (let Result (let V2518 (shen.lazyderef (tl V2505) V2761) (if (= () V2518) (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2518) (do (shen.bindv V2518 () V2761) (let Result (let Hyp (tl V2496) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons list (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2518 V2761) Result))) false))) (do (shen.unbindv V2506 V2761) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2519 (shen.lazyderef V2759 V2761) (if (cons? V2519) (let V2520 (shen.lazyderef (hd V2519) V2761) (if (cons? V2520) (let V2521 (shen.lazyderef (hd V2520) V2761) (if (cons? V2521) (let V2522 (shen.lazyderef (hd V2521) V2761) (if (= @p V2522) (let V2523 (shen.lazyderef (tl V2521) V2761) (if (cons? V2523) (let X (hd V2523) (let V2524 (shen.lazyderef (tl V2523) V2761) (if (cons? V2524) (let Y (hd V2524) (let V2525 (shen.lazyderef (tl V2524) V2761) (if (= () V2525) (let V2526 (shen.lazyderef (tl V2520) V2761) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2761) (if (= : V2527) (let V2528 (shen.lazyderef (tl V2526) V2761) (if (cons? V2528) (let V2529 (shen.lazyderef (hd V2528) V2761) (if (cons? V2529) (let A (hd V2529) (let V2530 (shen.lazyderef (tl V2529) V2761) (if (cons? V2530) (let V2531 (shen.lazyderef (hd V2530) V2761) (if (= * V2531) (let V2532 (shen.lazyderef (tl V2530) V2761) (if (cons? V2532) (let B (hd V2532) (let V2533 (shen.lazyderef (tl V2532) V2761) (if (= () V2533) (let V2534 (shen.lazyderef (tl V2528) V2761) (if (= () V2534) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2534) (do (shen.bindv V2534 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2534 V2761) Result))) false))) (if (shen.pvar? V2533) (do (shen.bindv V2533 () V2761) (let Result (let V2535 (shen.lazyderef (tl V2528) V2761) (if (= () V2535) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2535) (do (shen.bindv V2535 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2535 V2761) Result))) false))) (do (shen.unbindv V2533 V2761) Result))) false)))) (if (shen.pvar? V2532) (let B (shen.newpv V2761) (do (shen.bindv V2532 (cons B ()) V2761) (let Result (let V2536 (shen.lazyderef (tl V2528) V2761) (if (= () V2536) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2536) (do (shen.bindv V2536 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2536 V2761) Result))) false))) (do (shen.unbindv V2532 V2761) Result)))) false))) (if (shen.pvar? V2531) (do (shen.bindv V2531 * V2761) (let Result (let V2537 (shen.lazyderef (tl V2530) V2761) (if (cons? V2537) (let B (hd V2537) (let V2538 (shen.lazyderef (tl V2537) V2761) (if (= () V2538) (let V2539 (shen.lazyderef (tl V2528) V2761) (if (= () V2539) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2539) (do (shen.bindv V2539 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2539 V2761) Result))) false))) (if (shen.pvar? V2538) (do (shen.bindv V2538 () V2761) (let Result (let V2540 (shen.lazyderef (tl V2528) V2761) (if (= () V2540) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2540) (do (shen.bindv V2540 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2540 V2761) Result))) false))) (do (shen.unbindv V2538 V2761) Result))) false)))) (if (shen.pvar? V2537) (let B (shen.newpv V2761) (do (shen.bindv V2537 (cons B ()) V2761) (let Result (let V2541 (shen.lazyderef (tl V2528) V2761) (if (= () V2541) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2541) (do (shen.bindv V2541 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2541 V2761) Result))) false))) (do (shen.unbindv V2537 V2761) Result)))) false))) (do (shen.unbindv V2531 V2761) Result))) false))) (if (shen.pvar? V2530) (let B (shen.newpv V2761) (do (shen.bindv V2530 (cons * (cons B ())) V2761) (let Result (let V2542 (shen.lazyderef (tl V2528) V2761) (if (= () V2542) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2542) (do (shen.bindv V2542 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2542 V2761) Result))) false))) (do (shen.unbindv V2530 V2761) Result)))) false)))) (if (shen.pvar? V2529) (let A (shen.newpv V2761) (let B (shen.newpv V2761) (do (shen.bindv V2529 (cons A (cons * (cons B ()))) V2761) (let Result (let V2543 (shen.lazyderef (tl V2528) V2761) (if (= () V2543) (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2543) (do (shen.bindv V2543 () V2761) (let Result (let Hyp (tl V2519) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (shen.lazyderef B V2761) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2543 V2761) Result))) false))) (do (shen.unbindv V2529 V2761) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2544 (shen.lazyderef V2759 V2761) (if (cons? V2544) (let V2545 (shen.lazyderef (hd V2544) V2761) (if (cons? V2545) (let V2546 (shen.lazyderef (hd V2545) V2761) (if (cons? V2546) (let V2547 (shen.lazyderef (hd V2546) V2761) (if (= @v V2547) (let V2548 (shen.lazyderef (tl V2546) V2761) (if (cons? V2548) (let X (hd V2548) (let V2549 (shen.lazyderef (tl V2548) V2761) (if (cons? V2549) (let Y (hd V2549) (let V2550 (shen.lazyderef (tl V2549) V2761) (if (= () V2550) (let V2551 (shen.lazyderef (tl V2545) V2761) (if (cons? V2551) (let V2552 (shen.lazyderef (hd V2551) V2761) (if (= : V2552) (let V2553 (shen.lazyderef (tl V2551) V2761) (if (cons? V2553) (let V2554 (shen.lazyderef (hd V2553) V2761) (if (cons? V2554) (let V2555 (shen.lazyderef (hd V2554) V2761) (if (= vector V2555) (let V2556 (shen.lazyderef (tl V2554) V2761) (if (cons? V2556) (let A (hd V2556) (let V2557 (shen.lazyderef (tl V2556) V2761) (if (= () V2557) (let V2558 (shen.lazyderef (tl V2553) V2761) (if (= () V2558) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2558) (do (shen.bindv V2558 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2558 V2761) Result))) false))) (if (shen.pvar? V2557) (do (shen.bindv V2557 () V2761) (let Result (let V2559 (shen.lazyderef (tl V2553) V2761) (if (= () V2559) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2559) (do (shen.bindv V2559 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2559 V2761) Result))) false))) (do (shen.unbindv V2557 V2761) Result))) false)))) (if (shen.pvar? V2556) (let A (shen.newpv V2761) (do (shen.bindv V2556 (cons A ()) V2761) (let Result (let V2560 (shen.lazyderef (tl V2553) V2761) (if (= () V2560) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2560) (do (shen.bindv V2560 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2560 V2761) Result))) false))) (do (shen.unbindv V2556 V2761) Result)))) false))) (if (shen.pvar? V2555) (do (shen.bindv V2555 vector V2761) (let Result (let V2561 (shen.lazyderef (tl V2554) V2761) (if (cons? V2561) (let A (hd V2561) (let V2562 (shen.lazyderef (tl V2561) V2761) (if (= () V2562) (let V2563 (shen.lazyderef (tl V2553) V2761) (if (= () V2563) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2563) (do (shen.bindv V2563 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2563 V2761) Result))) false))) (if (shen.pvar? V2562) (do (shen.bindv V2562 () V2761) (let Result (let V2564 (shen.lazyderef (tl V2553) V2761) (if (= () V2564) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2564) (do (shen.bindv V2564 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2564 V2761) Result))) false))) (do (shen.unbindv V2562 V2761) Result))) false)))) (if (shen.pvar? V2561) (let A (shen.newpv V2761) (do (shen.bindv V2561 (cons A ()) V2761) (let Result (let V2565 (shen.lazyderef (tl V2553) V2761) (if (= () V2565) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2565) (do (shen.bindv V2565 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2565 V2761) Result))) false))) (do (shen.unbindv V2561 V2761) Result)))) false))) (do (shen.unbindv V2555 V2761) Result))) false))) (if (shen.pvar? V2554) (let A (shen.newpv V2761) (do (shen.bindv V2554 (cons vector (cons A ())) V2761) (let Result (let V2566 (shen.lazyderef (tl V2553) V2761) (if (= () V2566) (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2566) (do (shen.bindv V2566 () V2761) (let Result (let Hyp (tl V2544) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons (shen.lazyderef A V2761) ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons (cons vector (cons (shen.lazyderef A V2761) ())) ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2566 V2761) Result))) false))) (do (shen.unbindv V2554 V2761) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2567 (shen.lazyderef V2759 V2761) (if (cons? V2567) (let V2568 (shen.lazyderef (hd V2567) V2761) (if (cons? V2568) (let V2569 (shen.lazyderef (hd V2568) V2761) (if (cons? V2569) (let V2570 (shen.lazyderef (hd V2569) V2761) (if (= @s V2570) (let V2571 (shen.lazyderef (tl V2569) V2761) (if (cons? V2571) (let X (hd V2571) (let V2572 (shen.lazyderef (tl V2571) V2761) (if (cons? V2572) (let Y (hd V2572) (let V2573 (shen.lazyderef (tl V2572) V2761) (if (= () V2573) (let V2574 (shen.lazyderef (tl V2568) V2761) (if (cons? V2574) (let V2575 (shen.lazyderef (hd V2574) V2761) (if (= : V2575) (let V2576 (shen.lazyderef (tl V2574) V2761) (if (cons? V2576) (let V2577 (shen.lazyderef (hd V2576) V2761) (if (= string V2577) (let V2578 (shen.lazyderef (tl V2576) V2761) (if (= () V2578) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons string ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2578) (do (shen.bindv V2578 () V2761) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons string ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2578 V2761) Result))) false))) (if (shen.pvar? V2577) (do (shen.bindv V2577 string V2761) (let Result (let V2579 (shen.lazyderef (tl V2576) V2761) (if (= () V2579) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons string ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (if (shen.pvar? V2579) (do (shen.bindv V2579 () V2761) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2760 (cons (cons (shen.lazyderef X V2761) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2761) (cons : (cons string ()))) (shen.lazyderef Hyp V2761))) V2761 V2762))) (do (shen.unbindv V2579 V2761) Result))) false))) (do (shen.unbindv V2577 V2761) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2580 (shen.lazyderef V2759 V2761) (if (cons? V2580) (let X (hd V2580) (let Hyp (tl V2580) (let NewHyps (shen.newpv V2761) (do (shen.incinfs) (bind V2760 (cons (shen.lazyderef X V2761) (shen.lazyderef NewHyps V2761)) V2761 (freeze (shen.t*-hyps Hyp NewHyps V2761 V2762))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2779 V2780 V2781 V2782) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2779 V2781)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2780 V2781) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2782))))))))) (true (thaw V2782))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2784) (cond ((and (cons? V2784) (and (cons? (tl V2784)) (and (= : (hd (tl V2784))) (and (cons? (tl (tl V2784))) (= () (tl (tl (tl V2784)))))))) (shen.prhush (shen.app (hd V2784) (cn " : " (shen.app (hd (tl (tl V2784))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2784 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2789 V2790) (cond ((= () V2789) shen.skip) ((cons? V2789) (do (shen.prhush (shen.app V2790 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2789)) (do (nl 1) (shen.show-assumptions (tl V2789) (+ V2790 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2792) (cons? (assoc V2792 (value shen.*signedfuncs*))))

(defun shen.sigf (V2794) (concat shen.type-signature-of- V2794))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2799 V2800 V2801 V2802) (let Case (let V2483 (shen.lazyderef V2800 V2801) (if (= number V2483) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2799 V2801)) V2801 V2802)) (if (shen.pvar? V2483) (do (shen.bindv V2483 number V2801) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2799 V2801)) V2801 V2802)) (do (shen.unbindv V2483 V2801) Result))) false))) (if (= Case false) (let Case (let V2484 (shen.lazyderef V2800 V2801) (if (= boolean V2484) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2799 V2801)) V2801 V2802)) (if (shen.pvar? V2484) (do (shen.bindv V2484 boolean V2801) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2799 V2801)) V2801 V2802)) (do (shen.unbindv V2484 V2801) Result))) false))) (if (= Case false) (let Case (let V2485 (shen.lazyderef V2800 V2801) (if (= string V2485) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2799 V2801)) V2801 V2802)) (if (shen.pvar? V2485) (do (shen.bindv V2485 string V2801) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2799 V2801)) V2801 V2802)) (do (shen.unbindv V2485 V2801) Result))) false))) (if (= Case false) (let Case (let V2486 (shen.lazyderef V2800 V2801) (if (= symbol V2486) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2799 V2801)) V2801 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2799 V2801))) V2801 V2802)))) (if (shen.pvar? V2486) (do (shen.bindv V2486 symbol V2801) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2799 V2801)) V2801 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2799 V2801))) V2801 V2802)))) (do (shen.unbindv V2486 V2801) Result))) false))) (if (= Case false) (let V2487 (shen.lazyderef V2799 V2801) (if (= () V2487) (let V2488 (shen.lazyderef V2800 V2801) (if (cons? V2488) (let V2489 (shen.lazyderef (hd V2488) V2801) (if (= list V2489) (let V2490 (shen.lazyderef (tl V2488) V2801) (if (cons? V2490) (let A (hd V2490) (let V2491 (shen.lazyderef (tl V2490) V2801) (if (= () V2491) (do (shen.incinfs) (thaw V2802)) (if (shen.pvar? V2491) (do (shen.bindv V2491 () V2801) (let Result (do (shen.incinfs) (thaw V2802)) (do (shen.unbindv V2491 V2801) Result))) false)))) (if (shen.pvar? V2490) (let A (shen.newpv V2801) (do (shen.bindv V2490 (cons A ()) V2801) (let Result (do (shen.incinfs) (thaw V2802)) (do (shen.unbindv V2490 V2801) Result)))) false))) (if (shen.pvar? V2489) (do (shen.bindv V2489 list V2801) (let Result (let V2492 (shen.lazyderef (tl V2488) V2801) (if (cons? V2492) (let A (hd V2492) (let V2493 (shen.lazyderef (tl V2492) V2801) (if (= () V2493) (do (shen.incinfs) (thaw V2802)) (if (shen.pvar? V2493) (do (shen.bindv V2493 () V2801) (let Result (do (shen.incinfs) (thaw V2802)) (do (shen.unbindv V2493 V2801) Result))) false)))) (if (shen.pvar? V2492) (let A (shen.newpv V2801) (do (shen.bindv V2492 (cons A ()) V2801) (let Result (do (shen.incinfs) (thaw V2802)) (do (shen.unbindv V2492 V2801) Result)))) false))) (do (shen.unbindv V2489 V2801) Result))) false))) (if (shen.pvar? V2488) (let A (shen.newpv V2801) (do (shen.bindv V2488 (cons list (cons A ())) V2801) (let Result (do (shen.incinfs) (thaw V2802)) (do (shen.unbindv V2488 V2801) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2808 V2809 V2810 V2811 V2812) (let Case (let V2474 (shen.lazyderef V2810 V2811) (if (cons? V2474) (let V2475 (shen.lazyderef (hd V2474) V2811) (if (cons? V2475) (let Y (hd V2475) (let V2476 (shen.lazyderef (tl V2475) V2811) (if (cons? V2476) (let V2477 (shen.lazyderef (hd V2476) V2811) (if (= : V2477) (let V2478 (shen.lazyderef (tl V2476) V2811) (if (cons? V2478) (let B (hd V2478) (let V2479 (shen.lazyderef (tl V2478) V2811) (if (= () V2479) (do (shen.incinfs) (identical V2808 Y V2811 (freeze (unify! V2809 B V2811 V2812)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2480 (shen.lazyderef V2810 V2811) (if (cons? V2480) (let Hyp (tl V2480) (do (shen.incinfs) (shen.by_hypothesis V2808 V2809 Hyp V2811 V2812))) false)) Case)))

(defun shen.t*-def (V2818 V2819 V2820 V2821 V2822) (let V2468 (shen.lazyderef V2818 V2821) (if (cons? V2468) (let V2469 (shen.lazyderef (hd V2468) V2821) (if (= define V2469) (let V2470 (shen.lazyderef (tl V2468) V2821) (if (cons? V2470) (let F (hd V2470) (let X (tl V2470) (let Y (shen.newpv V2821) (let E (shen.newpv V2821) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2819 V2820 V2821 V2822)))))) false)) false)) false)))

(defun shen.t*-defh (V2829 V2830 V2831 V2832 V2833 V2834) (let V2464 (shen.lazyderef V2829 V2833) (if (cons? V2464) (let Sig (hd V2464) (let Rules (tl V2464) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2830 V2831 V2832 Rules V2833 V2834)))) false)))

(defun shen.t*-defhh (V2843 V2844 V2845 V2846 V2847 V2848 V2849 V2850) (do (shen.incinfs) (shen.t*-rules V2848 V2844 1 V2845 (cons (cons V2845 (cons : (cons V2844 ()))) V2847) V2849 (freeze (shen.memo V2845 V2843 V2846 V2849 V2850)))))

(defun shen.memo (V2856 V2857 V2858 V2859 V2860) (let Jnk (shen.newpv V2859) (do (shen.incinfs) (unify! V2858 V2857 V2859 (freeze (bind Jnk (declare (shen.lazyderef V2856 V2859) (shen.lazyderef V2858 V2859)) V2859 V2860))))))

(defun shen.<sig+rules> (V2862) (let Parse_shen.<signature> (shen.<signature> V2862) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2864) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2864) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2864) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2866) (cond ((and (cons? V2866) (and (cons? (tl V2866)) (and (= () (tl (tl V2866))) (= (hd V2866) protect)))) V2866) ((cons? V2866) (map (lambda Z (shen.ue Z)) V2866)) ((variable? V2866) (concat && V2866)) (true V2866)))

(defun shen.ue-sig (V2868) (cond ((cons? V2868) (map (lambda Z (shen.ue-sig Z)) V2868)) ((variable? V2868) (concat &&& V2868)) (true V2868)))

(defun shen.ues (V2874) (cond ((shen.ue? V2874) (cons V2874 ())) ((cons? V2874) (union (shen.ues (hd V2874)) (shen.ues (tl V2874)))) (true ())))

(defun shen.ue? (V2876) (and (symbol? V2876) (shen.ue-h? (str V2876))))

(defun shen.ue-h? (V2884) (cond ((and (shen.+string? V2884) (and (= "&" (pos V2884 0)) (and (shen.+string? (tlstr V2884)) (= "&" (pos (tlstr V2884) 0))))) true) (true false)))

(defun shen.t*-rules (V2892 V2893 V2894 V2895 V2896 V2897 V2898) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2448 (shen.lazyderef V2892 V2897) (if (= () V2448) (do (shen.incinfs) (thaw V2898)) false)) (if (= Case false) (let Case (let V2449 (shen.lazyderef V2892 V2897) (if (cons? V2449) (let Rule (hd V2449) (let Rules (tl V2449) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2893 V2896 V2897 (freeze (cut Throwcontrol V2897 (freeze (shen.t*-rules Rules V2893 (+ V2894 1) V2895 V2896 V2897 V2898)))))))) false)) (if (= Case false) (let Err (shen.newpv V2897) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2894 V2897) (cn " of " (shen.app (shen.lazyderef V2895 V2897) "" shen.a)) shen.a))) V2897 V2898))) Case)) Case)))))

(defun shen.t*-rule (V2904 V2905 V2906 V2907 V2908) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2440 (shen.lazyderef V2904 V2907) (if (cons? V2440) (let Patterns (hd V2440) (let V2441 (shen.lazyderef (tl V2440) V2907) (if (cons? V2441) (let Action (hd V2441) (let V2442 (shen.lazyderef (tl V2441) V2907) (if (= () V2442) (let NewHyps (shen.newpv V2907) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2906 NewHyps V2907 (freeze (shen.t*-patterns Patterns V2905 NewHyps V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2905) (shen.patthyps Patterns V2905 V2906) V2907 V2908))))))))) false))) false))) false)))))

(defun shen.placeholders (V2914) (cond ((shen.ue? V2914) (cons V2914 ())) ((cons? V2914) (union (shen.placeholders (hd V2914)) (shen.placeholders (tl V2914)))) (true ())))

(defun shen.newhyps (V2920 V2921 V2922 V2923 V2924) (let Case (let V2427 (shen.lazyderef V2920 V2923) (if (= () V2427) (do (shen.incinfs) (unify! V2922 V2921 V2923 V2924)) false)) (if (= Case false) (let V2428 (shen.lazyderef V2920 V2923) (if (cons? V2428) (let V2423 (hd V2428) (let Vs (tl V2428) (let V2429 (shen.lazyderef V2922 V2923) (if (cons? V2429) (let V2430 (shen.lazyderef (hd V2429) V2923) (if (cons? V2430) (let V (hd V2430) (let V2431 (shen.lazyderef (tl V2430) V2923) (if (cons? V2431) (let V2432 (shen.lazyderef (hd V2431) V2923) (if (= : V2432) (let V2433 (shen.lazyderef (tl V2431) V2923) (if (cons? V2433) (let A (hd V2433) (let V2434 (shen.lazyderef (tl V2433) V2923) (if (= () V2434) (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (if (shen.pvar? V2434) (do (shen.bindv V2434 () V2923) (let Result (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (do (shen.unbindv V2434 V2923) Result))) false)))) (if (shen.pvar? V2433) (let A (shen.newpv V2923) (do (shen.bindv V2433 (cons A ()) V2923) (let Result (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (do (shen.unbindv V2433 V2923) Result)))) false))) (if (shen.pvar? V2432) (do (shen.bindv V2432 : V2923) (let Result (let V2435 (shen.lazyderef (tl V2431) V2923) (if (cons? V2435) (let A (hd V2435) (let V2436 (shen.lazyderef (tl V2435) V2923) (if (= () V2436) (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (if (shen.pvar? V2436) (do (shen.bindv V2436 () V2923) (let Result (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (do (shen.unbindv V2436 V2923) Result))) false)))) (if (shen.pvar? V2435) (let A (shen.newpv V2923) (do (shen.bindv V2435 (cons A ()) V2923) (let Result (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (do (shen.unbindv V2435 V2923) Result)))) false))) (do (shen.unbindv V2432 V2923) Result))) false))) (if (shen.pvar? V2431) (let A (shen.newpv V2923) (do (shen.bindv V2431 (cons : (cons A ())) V2923) (let Result (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (do (shen.unbindv V2431 V2923) Result)))) false)))) (if (shen.pvar? V2430) (let V (shen.newpv V2923) (let A (shen.newpv V2923) (do (shen.bindv V2430 (cons V (cons : (cons A ()))) V2923) (let Result (let NewHyp (tl V2429) (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924))))) (do (shen.unbindv V2430 V2923) Result))))) false))) (if (shen.pvar? V2429) (let V (shen.newpv V2923) (let A (shen.newpv V2923) (let NewHyp (shen.newpv V2923) (do (shen.bindv V2429 (cons (cons V (cons : (cons A ()))) NewHyp) V2923) (let Result (do (shen.incinfs) (unify! V V2423 V2923 (freeze (shen.newhyps Vs V2921 NewHyp V2923 V2924)))) (do (shen.unbindv V2429 V2923) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2930 V2931 V2932) (cond ((= () V2930) V2932) ((and (cons? V2930) (and (cons? V2931) (and (cons? (tl V2931)) (and (= --> (hd (tl V2931))) (and (cons? (tl (tl V2931))) (= () (tl (tl (tl V2931))))))))) (adjoin (cons (hd V2930) (cons : (cons (hd V2931) ()))) (shen.patthyps (tl V2930) (hd (tl (tl V2931))) V2932))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2939 V2940) (cond ((and (= () V2939) (and (cons? V2940) (and (= --> (hd V2940)) (and (cons? (tl V2940)) (= () (tl (tl V2940))))))) (hd (tl V2940))) ((= () V2939) V2940) ((and (cons? V2939) (and (cons? V2940) (and (cons? (tl V2940)) (and (= --> (hd (tl V2940))) (and (cons? (tl (tl V2940))) (= () (tl (tl (tl V2940))))))))) (shen.result-type (tl V2939) (hd (tl (tl V2940))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2946 V2947 V2948 V2949 V2950) (let Case (let V2415 (shen.lazyderef V2946 V2949) (if (= () V2415) (do (shen.incinfs) (thaw V2950)) false)) (if (= Case false) (let V2416 (shen.lazyderef V2946 V2949) (if (cons? V2416) (let Pattern (hd V2416) (let Patterns (tl V2416) (let V2417 (shen.lazyderef V2947 V2949) (if (cons? V2417) (let A (hd V2417) (let V2418 (shen.lazyderef (tl V2417) V2949) (if (cons? V2418) (let V2419 (shen.lazyderef (hd V2418) V2949) (if (= --> V2419) (let V2420 (shen.lazyderef (tl V2418) V2949) (if (cons? V2420) (let B (hd V2420) (let V2421 (shen.lazyderef (tl V2420) V2949) (if (= () V2421) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V2948 V2949 (freeze (shen.t*-patterns Patterns B V2948 V2949 V2950)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2956 V2957 V2958 V2959 V2960) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2392 (shen.lazyderef V2956 V2959) (if (cons? V2392) (let V2393 (shen.lazyderef (hd V2392) V2959) (if (= where V2393) (let V2394 (shen.lazyderef (tl V2392) V2959) (if (cons? V2394) (let P (hd V2394) (let V2395 (shen.lazyderef (tl V2394) V2959) (if (cons? V2395) (let Action (hd V2395) (let V2396 (shen.lazyderef (tl V2395) V2959) (if (= () V2396) (do (shen.incinfs) (cut Throwcontrol V2959 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2958 V2959 (freeze (cut Throwcontrol V2959 (freeze (shen.t*-action Action V2957 (cons (cons P (cons : (cons verified ()))) V2958) V2959 V2960)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2397 (shen.lazyderef V2956 V2959) (if (cons? V2397) (let V2398 (shen.lazyderef (hd V2397) V2959) (if (= shen.choicepoint! V2398) (let V2399 (shen.lazyderef (tl V2397) V2959) (if (cons? V2399) (let V2400 (shen.lazyderef (hd V2399) V2959) (if (cons? V2400) (let V2401 (shen.lazyderef (hd V2400) V2959) (if (cons? V2401) (let V2402 (shen.lazyderef (hd V2401) V2959) (if (= fail-if V2402) (let V2403 (shen.lazyderef (tl V2401) V2959) (if (cons? V2403) (let F (hd V2403) (let V2404 (shen.lazyderef (tl V2403) V2959) (if (= () V2404) (let V2405 (shen.lazyderef (tl V2400) V2959) (if (cons? V2405) (let Action (hd V2405) (let V2406 (shen.lazyderef (tl V2405) V2959) (if (= () V2406) (let V2407 (shen.lazyderef (tl V2399) V2959) (if (= () V2407) (do (shen.incinfs) (cut Throwcontrol V2959 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2957 V2958 V2959 V2960)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2408 (shen.lazyderef V2956 V2959) (if (cons? V2408) (let V2409 (shen.lazyderef (hd V2408) V2959) (if (= shen.choicepoint! V2409) (let V2410 (shen.lazyderef (tl V2408) V2959) (if (cons? V2410) (let Action (hd V2410) (let V2411 (shen.lazyderef (tl V2410) V2959) (if (= () V2411) (do (shen.incinfs) (cut Throwcontrol V2959 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2957 V2958 V2959 V2960)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2956 (cons : (cons V2957 ()))) V2958 V2959 V2960)) Case)) Case)) Case)))))

(defun findall (V2966 V2967 V2968 V2969 V2970) (let B (shen.newpv V2969) (let A (shen.newpv V2969) (do (shen.incinfs) (bind A (gensym shen.a) V2969 (freeze (bind B (set (shen.lazyderef A V2969) ()) V2969 (freeze (shen.findallhelp V2966 V2967 V2968 A V2969 V2970)))))))))

(defun shen.findallhelp (V2977 V2978 V2979 V2980 V2981 V2982) (let Case (do (shen.incinfs) (call V2978 V2981 (freeze (shen.remember V2980 V2977 V2981 (freeze (fwhen false V2981 V2982)))))) (if (= Case false) (do (shen.incinfs) (bind V2979 (value (shen.lazyderef V2980 V2981)) V2981 V2982)) Case)))

(defun shen.remember (V2987 V2988 V2989 V2990) (let B (shen.newpv V2989) (do (shen.incinfs) (bind B (set (shen.deref V2987 V2989) (cons (shen.deref V2988 V2989) (value (shen.deref V2987 V2989)))) V2989 V2990))))



